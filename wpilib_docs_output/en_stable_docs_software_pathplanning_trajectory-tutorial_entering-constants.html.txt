Step 2: Entering the Calculated Constants

Note
In C++, it is important that the feedforward constants be entered as the correct unit type.  For more information on C++ units, see
The C++ Units Library
.
Now that we have our system constants, it is time to place them in our code.  The recommended place for this is the
Constants
file of the
standard command-based project structure
.
The relevant parts of the constants file from the RamseteCommand Example Project (
Java
,
C++
) can be seen below.
Feedforward/Feedback Gains

Firstly, we must enter the feedforward and feedback gains which we obtained from the identification tool.
Note
Feedforward and feedback gains do
not
, in general, transfer across robots.  Do
not
use the gains from this tutorial for your own robot.
JAVA
39
// These are example values only - DO NOT USE THESE FOR YOUR OWN ROBOT!
40
// These characterization values MUST be determined either experimentally or theoretically
41
// for *your* robot's drive.
42
// The Robot Characterization Toolsuite provides a convenient tool for obtaining these
43
// values for your robot.
44
public
static
final
double
ksVolts
=
0.22
;
45
public
static
final
double
kvVoltSecondsPerMeter
=
1.98
;
46
public
static
final
double
kaVoltSecondsSquaredPerMeter
=
0.2
;
47
48
// Example value only - as above, this must be tuned for your drive!
49
public
static
final
double
kPDriveVel
=
8.5
;
C++
47
// These are example values only - DO NOT USE THESE FOR YOUR OWN ROBOT!
48
// These characterization values MUST be determined either experimentally or
49
// theoretically for *your* robot's drive. The Robot Characterization
50
// Toolsuite provides a convenient tool for obtaining these values for your
51
// robot.
52
inline
constexpr
auto
ks
=
0.22
_V
;
53
inline
constexpr
auto
kv
=
1.98
*
1
_V
*
1
_s
/
1
_m
;
54
inline
constexpr
auto
ka
=
0.2
*
1
_V
*
1
_s
*
1
_s
/
1
_m
;
55
56
// Example value only - as above, this must be tuned for your drive!
57
inline
constexpr
double
kPDriveVel
=
8.5
;
DifferentialDriveKinematics

Additionally, we must create an instance of the
DifferentialDriveKinematics
class, which allows us to use the trackwidth (i.e. horizontal distance between the wheels) of the robot to convert from chassis speeds to wheel speeds.  As elsewhere, we keep our units in meters.
JAVA
29
public
static
final
double
kTrackwidthMeters
=
0.69
;
30
public
static
final
DifferentialDriveKinematics
kDriveKinematics
=
31
new
DifferentialDriveKinematics
(
kTrackwidthMeters
);
C++
38
inline
constexpr
auto
kTrackwidth
=
0.69
_m
;
39
extern
const
frc
::
DifferentialDriveKinematics
kDriveKinematics
;
Max Trajectory Velocity/Acceleration

We must also decide on a nominal max acceleration and max velocity for the robot during path-following.  The maximum velocity value should be set somewhat below the nominal free-speed of the robot.  Due to the later use of the
DifferentialDriveVoltageConstraint
, the maximum acceleration value is not extremely crucial.
Warning
Max velocity and acceleration, as defined here, are applied only during trajectory generation.  They do not limit the
RamseteCommand
itself, which may give values to the
DriveSubsystem
that can cause the robot to greatly exceed these velocities and accelerations.
JAVA
57
public
static
final
double
kMaxSpeedMetersPerSecond
=
3
;
58
public
static
final
double
kMaxAccelerationMetersPerSecondSquared
=
1
;
C++
61
inline
constexpr
auto
kMaxSpeed
=
3
_mps
;
62
inline
constexpr
auto
kMaxAcceleration
=
1
_mps_sq
;
Ramsete Parameters

Finally, we must include a pair of parameters for the RAMSETE controller.  The values
b
and
zeta
shown below should work well for most robots, provided distances have been correctly measured in meters.
Larger values of
b
make convergence more aggressive like a proportional term whereas larger values of
zeta
provide more damping in the response. These controller gains only dictate how the controller will output adjusted velocities. It does NOT affect the actual velocity tracking of the robot. This means that these controller gains are generally robot-agnostic.
Note
Gains of
2.0
and
0.7
for
b
and
zeta
have been tested repeatedly to produce desirable results when all units were in meters. As such, a zero-argument constructor for
RamseteController
exists with gains defaulted to these values.
JAVA
60
// Reasonable baseline values for a RAMSETE follower in units of meters and seconds
61
public
static
final
double
kRamseteB
=
2
;
62
public
static
final
double
kRamseteZeta
=
0.7
;
C++
64
// Reasonable baseline values for a RAMSETE follower in units of meters and
65
// seconds
66
inline
constexpr
auto
kRamseteB
=
2.0
*
1
_rad
*
1
_rad
/
(
1
_m
*
1
_m
);
67
inline
constexpr
auto
kRamseteZeta
=
0.7
/
1
_rad
;