Analog Potentiometers - Software

Note
This section covers analog potentiometers in software.  For a hardware guide to analog potentiometers, see
Analog Potentiometers - Hardware
.
Potentiometers are variable resistors that allow information about position to be converted into an analog voltage signal.  This signal can be read by the roboRIO to control whatever device is attached to the potentiometer.
While it is possible to read information from a potentiometer directly with an
Analog Inputs - Software
, WPILib provides an
AnalogPotentiometer
class (
Java
,
C++
) that handles re-scaling the values into meaningful units for the user.  It is strongly encouraged to use this class.
In fact, the
AnalogPotentiometer
name is something of a misnomer - this class should be used for the vast majority of sensors that return their signal as a simple, linearly-scaled analog voltage.
The AnalogPotentiometer class

Note
The “full range” or “scale” parameters in the
AnalogPotentiometer
constructor are scale factors from a range of 0-1 to the actual range,
not
from 0-5.  That is, they represent a native fractional scale, rather than a voltage scale.
An AnalogPotentiometer can be initialized as follows:
JAVA
// Initializes an AnalogPotentiometer on analog port 0
// The full range of motion (in meaningful external units) is 0-180 (this could be degrees, for
// instance)
// The "starting point" of the motion, i.e. where the mechanism is located when the potentiometer
// reads 0v, is 30.
AnalogPotentiometer
m_pot
=
new
AnalogPotentiometer
(
0
,
180
,
30
);
C++
// Initializes an AnalogPotentiometer on analog port 0
// The full range of motion (in meaningful external units) is 0-180 (this
// could be degrees, for instance) The "starting point" of the motion, i.e.
// where the mechanism is located when the potentiometer reads 0v, is 30.
frc
::
AnalogPotentiometer
m_pot
{
0
,
180
,
30
};
Customizing the underlying AnalogInput

Note
If the user changes the scaling of the
AnalogInput
with oversampling, this must be reflected in the scale setting passed to the
AnalogPotentiometer
.
If the user would like to apply custom settings to the underlying
AnalogInput
used by the
AnalogPotentiometer
, an alternative constructor may be used in which the
AnalogInput
is injected:
JAVA
// Initializes an AnalogInput on port 1
AnalogInput
m_input
=
new
AnalogInput
(
0
);
// Initializes an AnalogPotentiometer with the given AnalogInput
// The full range of motion (in meaningful external units) is 0-180 (this could be degrees, for
// instance)
// The "starting point" of the motion, i.e. where the mechanism is located when the potentiometer
// reads 0v, is 30.
AnalogPotentiometer
m_pot1
=
new
AnalogPotentiometer
(
m_input
,
180
,
30
);
C++
// Initializes an AnalogInput on port 1
frc
::
AnalogInput
m_input
{
1
};
// Initializes an AnalogPotentiometer with the given AnalogInput
// The full range of motion (in meaningful external units) is 0-180 (this
// could be degrees, for instance) The "starting point" of the motion, i.e.
// where the mechanism is located when the potentiometer reads 0v, is 30.
frc
::
AnalogPotentiometer
m_pot1
{
&
m_input
,
180
,
30
};
Reading values from the AnalogPotentiometer

The scaled value can be read by simply calling the
get
method:
JAVA
// Get the value of the potentiometer
m_pot
.
get
();
C++
// Get the value of the potentiometer
m_pot
.
Get
();
Using AnalogPotentiometers in code

Analog sensors can be used in code much in the way other sensors that measure the same thing can be.  If the analog sensor is a potentiometer measuring an arm angle, it can be used similarly to an
encoder
.  If it is an ultrasonic sensor, it can be used similarly to other
ultrasonics
.
It is very important to keep in mind that actual, physical potentiometers generally have a limited range of motion.  Safeguards should be present in both the physical mechanism and the code to ensure that the mechanism does not break the sensor by traveling past its maximum throw.