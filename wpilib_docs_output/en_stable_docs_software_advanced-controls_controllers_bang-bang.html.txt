Bang-Bang Control with BangBangController

The
bang-bang control
algorithm is a control strategy that employs only two states: on (when the measurement is below the setpoint) and off (otherwise).  This is roughly equivalent to a proportional loop with infinite gain.
This may initially seem like a poor control strategy, as PID loops are known to become unstable as the gains become large - and indeed, it is a
very bad idea to use a bang-bang controller on anything other than velocity control of a high-inertia mechanism
.
However, when controlling the velocity of high-inertia mechanisms under varying loads (like a shooter flywheel), a bang-bang controller can yield faster recovery time and thus better/more consistent performance than a proportional controller.  Unlike an ordinary P loop, a bang-bang controller is
asymmetric
- that is, the controller turns on when the process variable is below the setpoint, and does nothing otherwise.  This allows the control effort in the forward direction to be made as large as possible without risking destructive oscillations as the control loop tries to correct a resulting overshoot.
Asymmetric bang-bang control is provided in WPILib by the BangBangController class (
Java
,
C++
,
Python
).
Constructing a BangBangController

Since a bang-bang controller does not have any gains, it does not need any constructor arguments (one can optionally specify the controller tolerance used by
atSetpoint
, but it is not required).
JAVA
// Creates a BangBangController
BangBangController
controller
=
new
BangBangController
();
C++
// Creates a BangBangController
frc
::
BangBangController
controller
;
PYTHON
from
wpimath.controller
import
BangBangController
# Creates a BangBangController
controller
=
BangBangController
()
Using a BangBangController

Warning
Bang-bang control is an extremely aggressive algorithm that relies on response asymmetry to remain stable.  Be
absolutely certain
that your motor controllers have been set to “coast mode” before attempting to control them with a bang-bang controller, or else the braking action will fight the controller and cause potentially destructive oscillation.
Using a bang-bang controller is easy:
JAVA
// Controls a motor with the output of the BangBang controller
motor
.
set
(
controller
.
calculate
(
encoder
.
getRate
(),
setpoint
));
C++
// Controls a motor with the output of the BangBang controller
motor
.
Set
(
controller
.
Calculate
(
encoder
.
GetRate
(),
setpoint
));
PYTHON
# Controls a motor with the output of the BangBang controller
motor
.
set
(
controller
.
calculate
(
encoder
.
getRate
(),
setpoint
))
Combining Bang Bang Control with Feedforward

Like a PID controller, best results are obtained in conjunction with a
feedforward
controller that provides the necessary voltage to sustain the system output at the desired speed, so that the bang-bang controller is only responsible for rejecting disturbances.  Since the bang-bang controller can
only
correct in the forward direction, however, it may be preferable to use a slightly conservative feedforward estimate to ensure that the shooter does not over-speed.
JAVA
// Controls a motor with the output of the BangBang controller and a feedforward
// Shrinks the feedforward slightly to avoid overspeeding the shooter
motor
.
setVoltage
(
controller
.
calculate
(
encoder
.
getRate
(),
setpoint
)
*
12.0
+
0.9
*
feedforward
.
calculate
(
setpoint
));
C++
// Controls a motor with the output of the BangBang controller and a feedforward
// Shrinks the feedforward slightly to avoid overspeeding the shooter
motor
.
SetVoltage
(
controller
.
Calculate
(
encoder
.
GetRate
(),
setpoint
)
*
12.0
+
0.9
*
feedforward
.
Calculate
(
setpoint
));
PYTHON
# Controls a motor with the output of the BangBang controller and a feedforward
motor
.
setVoltage
(
controller
.
calculate
(
encoder
.
getRate
(),
setpoint
)
*
12.0
+
0.9
*
feedforward
.
calculate
(
setpoint
))