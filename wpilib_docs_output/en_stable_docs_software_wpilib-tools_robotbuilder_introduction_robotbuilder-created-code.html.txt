RobotBuilder Created Code

The Layout of a RobotBuilder Generated Project

A RobotBuilder generated project consists of a package (in Java) or a folder (in C++) for Commands and another for Subsystems. Each command or subsystem object is stored under those containers. At the top level of the project you’ll find the robot main program (RobotContainer.java/C++).
For more information on the organization of a Command Based robot, see
Structuring a Command-Based Robot Project
Autogenerated Code

JAVA
// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=AUTONOMOUS
m_chooser
.
setDefaultOption
(
"Autonomous"
,
new
Autonomous
());
// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=AUTONOMOUS
SmartDashboard
.
putData
(
"Auto Mode"
,
m_chooser
);
C++
// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=AUTONOMOUS
m_chooser
.
SetDefaultOption
(
"Autonomous"
,
new
Autonomous
());
// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=AUTONOMOUS
frc
::
SmartDashboard
::
PutData
(
"Auto Mode"
,
&
m_chooser
);
When the robot description is modified and code is re-exported RobotBuilder is designed to not modify any changes you made to the file, thus preserving your code. This makes RobotBuilder a full-lifecycle tool. To know what code is OK to be modified by RobotBuilder, it generates sections that will potentially have to be rewritten delimited with some special comments. These comments are shown in the example above. Don’t add any code within these comment blocks, it will be rewritten next time the project is exported from RobotBuilder.
If code inside one of these blocks must be modified, the comments can be removed, but this will prevent further updates from happening later. In the above example, if the //BEGIN and //END comments were removed, then later another required subsystem was added in RobotBuilder, it would not be generated on that next export.
JAVA
// ROBOTBUILDER TYPE: Robot.
C++
// ROBOTBUILDER TYPE: Robot.
Additionally, each file has a comment defining the type of file. If this is modified or deleted, RobotBuilder will completely regenerate the file deleting any code added both inside and outside the AUTOGENERATED CODE blocks.
Main Robot Program

Java
11
// ROBOTBUILDER TYPE: Robot.
12
13
package
frc.robot
;
14
15
import
edu.wpi.first.hal.FRCNetComm.tInstances
;
16
import
edu.wpi.first.hal.FRCNetComm.tResourceType
;
17
import
edu.wpi.first.hal.HAL
;
18
import
edu.wpi.first.wpilibj.TimedRobot
;
19
import
edu.wpi.first.wpilibj2.command.Command
;
20
import
edu.wpi.first.wpilibj2.command.CommandScheduler
;
21
22
/**
23
* The methods in this class are called automatically corresponding to each mode, as described in
24
* the TimedRobot documentation. If you change the name of this class or the package after creating
25
* this project, you must also update the Main.java file in the project.
26
*/
27
public
class
Robot
extends
TimedRobot
{
28
29
private
Command
m_autonomousCommand
;
30
31
private
RobotContainer
m_robotContainer
;
32
33
/**
34
* This function is run when the robot is first started up and should be
35
* used for any initialization code.
36
*/
37
public
Robot
()
{
38
// Instantiate our RobotContainer.  This will perform all our button bindings, and put our
39
// autonomous chooser on the dashboard.
40
m_robotContainer
=
RobotContainer
.
getInstance
();
41
HAL
.
report
(
tResourceType
.
kResourceType_Framework
,
tInstances
.
kFramework_RobotBuilder
);
42
enableLiveWindowInTest
(
true
);
43
}
44
45
/**
46
* This function is called every robot packet, no matter the mode. Use this for items like
47
* diagnostics that you want ran during disabled, autonomous, teleoperated and test.
48
*
49
* <p>This runs after the mode specific periodic functions, but before
50
* LiveWindow and SmartDashboard integrated updating.
51
*/
52
@Override
53
public
void
robotPeriodic
()
{
54
// Runs the Scheduler.  This is responsible for polling buttons, adding newly-scheduled
55
// commands, running already-scheduled commands, removing finished or interrupted commands,
56
// and running subsystem periodic() methods.  This must be called from the robot's periodic
57
// block in order for anything in the Command-based framework to work.
58
CommandScheduler
.
getInstance
().
run
();
59
}
60
61
62
/**
63
* This function is called once each time the robot enters Disabled mode.
64
*/
65
@Override
66
public
void
disabledInit
()
{
67
}
68
69
@Override
70
public
void
disabledPeriodic
()
{
71
}
72
73
/**
74
* This autonomous runs the autonomous command selected by your {@link RobotContainer} class.
75
*/
76
@Override
77
public
void
autonomousInit
()
{
78
m_autonomousCommand
=
m_robotContainer
.
getAutonomousCommand
();
79
80
// schedule the autonomous command (example)
81
if
(
m_autonomousCommand
!=
null
)
{
82
m_autonomousCommand
.
schedule
();
83
}
84
}
85
86
/**
87
* This function is called periodically during autonomous.
88
*/
89
@Override
90
public
void
autonomousPeriodic
()
{
91
}
92
93
@Override
94
public
void
teleopInit
()
{
95
// This makes sure that the autonomous stops running when
96
// teleop starts running. If you want the autonomous to
97
// continue until interrupted by another command, remove
98
// this line or comment it out.
99
if
(
m_autonomousCommand
!=
null
)
{
100
m_autonomousCommand
.
cancel
();
101
}
102
}
103
104
/**
105
* This function is called periodically during operator control.
106
*/
107
@Override
108
public
void
teleopPeriodic
()
{
109
}
110
111
@Override
112
public
void
testInit
()
{
113
// Cancels all running commands at the start of test mode.
114
CommandScheduler
.
getInstance
().
cancelAll
();
115
}
116
117
/**
118
* This function is called periodically during test mode.
119
*/
120
@Override
121
public
void
testPeriodic
()
{
122
}
123
124
}
C++ (Header)
11
// ROBOTBUILDER TYPE: Robot.
12
#pragma once
13
14
#include
<frc/TimedRobot.h>
15
#include
<frc2/command/Command.h>
16
17
#include
"RobotContainer.h"
18
19
class
Robot
:
public
frc
::
TimedRobot
{
20
public
:
21
Robot
();
22
void
RobotPeriodic
()
override
;
23
void
DisabledInit
()
override
;
24
void
DisabledPeriodic
()
override
;
25
void
AutonomousInit
()
override
;
26
void
AutonomousPeriodic
()
override
;
27
void
TeleopInit
()
override
;
28
void
TeleopPeriodic
()
override
;
29
void
TestPeriodic
()
override
;
30
31
private
:
32
// Have it null by default so that if testing teleop it
33
// doesn't have undefined behavior and potentially crash.
34
frc2
::
Command
*
m_autonomousCommand
=
nullptr
;
35
36
RobotContainer
*
m_container
=
RobotContainer
::
GetInstance
();
37
};
C++ (Source)
11
// ROBOTBUILDER TYPE: Robot.
12
13
#include
"Robot.h"
14
15
#include
<hal/FRCUsageReporting.h>
16
17
#include
<frc/smartdashboard/SmartDashboard.h>
18
#include
<frc2/command/CommandScheduler.h>
19
20
Robot
::
Robot
()
{
21
EnableLiveWindowInTest
(
true
);
22
HAL_Report
(
HALUsageReporting
::
kResourceType_Framework
,
23
HALUsageReporting
::
kFramework_RobotBuilder
);
24
}
25
26
/**
27
* This function is called every robot packet, no matter the mode. Use
28
* this for items like diagnostics that you want to run during disabled,
29
* autonomous, teleoperated and test.
30
*
31
* <p> This runs after the mode specific periodic functions, but before
32
* LiveWindow and SmartDashboard integrated updating.
33
*/
34
void
Robot
::
RobotPeriodic
()
{
frc2
::
CommandScheduler
::
GetInstance
().
Run
();
}
35
36
/**
37
* This function is called once each time the robot enters Disabled mode. You
38
* can use it to reset any subsystem information you want to clear when the
39
* robot is disabled.
40
*/
41
void
Robot
::
DisabledInit
()
{}
42
43
void
Robot
::
DisabledPeriodic
()
{}
44
45
/**
46
* This autonomous runs the autonomous command selected by your {@link
47
* RobotContainer} class.
48
*/
49
void
Robot
::
AutonomousInit
()
{
50
m_autonomousCommand
=
m_container
->
GetAutonomousCommand
();
51
52
if
(
m_autonomousCommand
!=
nullptr
)
{
53
m_autonomousCommand
->
Schedule
();
54
}
55
}
56
57
void
Robot
::
AutonomousPeriodic
()
{}
58
59
void
Robot
::
TeleopInit
()
{
60
// This makes sure that the autonomous stops running when
61
// teleop starts running. If you want the autonomous to
62
// continue until interrupted by another command, remove
63
// this line or comment it out.
64
if
(
m_autonomousCommand
!=
nullptr
)
{
65
m_autonomousCommand
->
Cancel
();
66
m_autonomousCommand
=
nullptr
;
67
}
68
}
69
70
/**
71
* This function is called periodically during operator control.
72
*/
73
void
Robot
::
TeleopPeriodic
()
{}
74
75
/**
76
* This function is called periodically during test mode.
77
*/
78
void
Robot
::
TestPeriodic
()
{}
79
80
#ifndef RUNNING_FRC_TESTS
81
int
main
()
{
return
frc
::
StartRobot
<
Robot
>
();
}
82
#endif
This is the main program generated by RobotBuilder. There are a number of parts to this program (highlighted sections):
This class extends TimedRobot. TimedRobot will call your
autonomousPeriodic()
and
teleopPeriodic()
methods every 20ms.
In the robotPeriodic method which is called every 20ms, make one scheduling pass.
The autonomous command provided is scheduled at the start of autonomous in the
autonomousInit()
method and canceled at the end of the autonomous period in
teleopInit()
.
RobotContainer

Java
11
// ROBOTBUILDER TYPE: RobotContainer.
12
13
package
frc.robot
;
14
15
import
frc.robot.commands.*
;
16
import
frc.robot.subsystems.*
;
17
import
edu.wpi.first.wpilibj.smartdashboard.SendableChooser
;
18
import
edu.wpi.first.wpilibj.smartdashboard.SmartDashboard
;
19
import
edu.wpi.first.wpilibj2.command.Command.InterruptionBehavior
;
20
21
// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS
22
import
edu.wpi.first.wpilibj2.command.Command
;
23
import
edu.wpi.first.wpilibj2.command.InstantCommand
;
24
import
edu.wpi.first.wpilibj.Joystick
;
25
import
edu.wpi.first.wpilibj2.command.button.JoystickButton
;
26
import
frc.robot.subsystems.*
;
27
28
// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS
29
30
31
/**
32
* This class is where the bulk of the robot should be declared.  Since Command-based is a
33
* "declarative" paradigm, very little robot logic should actually be handled in the {@link Robot}
34
* periodic methods (other than the scheduler calls).  Instead, the structure of the robot
35
* (including subsystems, commands, and button mappings) should be declared here.
36
*/
37
public
class
RobotContainer
{
38
39
private
static
RobotContainer
m_robotContainer
=
new
RobotContainer
();
40
41
// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
42
// The robot's subsystems
43
public
final
Wrist
m_wrist
=
new
Wrist
();
44
public
final
Elevator
m_elevator
=
new
Elevator
();
45
public
final
Claw
m_claw
=
new
Claw
();
46
public
final
DriveTrain
m_driveTrain
=
new
DriveTrain
();
47
48
// Joysticks
49
private
final
Joystick
joystick2
=
new
Joystick
(
2
);
50
private
final
Joystick
joystick1
=
new
Joystick
(
1
);
51
private
final
Joystick
logitechController
=
new
Joystick
(
0
);
52
53
// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
54
55
56
// A chooser for autonomous commands
57
SendableChooser
<
Command
>
m_chooser
=
new
SendableChooser
<>
();
58
59
/**
60
* The container for the robot.  Contains subsystems, OI devices, and commands.
61
*/
62
private
RobotContainer
()
{
63
// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=SMARTDASHBOARD
64
// Smartdashboard Subsystems
65
SmartDashboard
.
putData
(
m_wrist
);
66
SmartDashboard
.
putData
(
m_elevator
);
67
SmartDashboard
.
putData
(
m_claw
);
68
SmartDashboard
.
putData
(
m_driveTrain
);
69
70
71
// SmartDashboard Buttons
72
SmartDashboard
.
putData
(
"Close Claw"
,
new
CloseClaw
(
m_claw
));
73
SmartDashboard
.
putData
(
"Open Claw: default"
,
new
OpenClaw
(
1
));
74
SmartDashboard
.
putData
(
"Pickup"
,
new
Pickup
());
75
SmartDashboard
.
putData
(
"Place"
,
new
Place
());
76
SmartDashboard
.
putData
(
"Prepare To Pickup"
,
new
PrepareToPickup
());
77
SmartDashboard
.
putData
(
"Set Elevator Setpoint: down"
,
new
SetElevatorSetpoint
(
1
,
m_elevator
));
78
SmartDashboard
.
putData
(
"Set Elevator Setpoint: up"
,
new
SetElevatorSetpoint
(
2
,
m_elevator
));
79
SmartDashboard
.
putData
(
"Set Wrist Setpoint: Horizontal"
,
new
SetWristSetpoint
(
0
,
m_elevator
));
80
SmartDashboard
.
putData
(
"Set Wrist Setpoint: Raise Wrist"
,
new
SetWristSetpoint
(
-
45
,
m_elevator
));
81
SmartDashboard
.
putData
(
"Tank Drive: joystick"
,
new
TankDrive
(()
->
getJoystick1
().
getY
(),
()
->
getJoystick2
().
getY
(),
m_driveTrain
));
82
SmartDashboard
.
putData
(
"DriveAuto: default"
,
new
DriveAuto
(
10
,
0
));
83
84
// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=SMARTDASHBOARD
85
// Configure the button bindings
86
configureButtonBindings
();
87
88
// Configure default commands
89
// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=SUBSYSTEM_DEFAULT_COMMAND
90
m_driveTrain
.
setDefaultCommand
(
new
TankDrive
(()
->
getJoystick1
().
getY
(),
()
->
getJoystick2
().
getY
(),
m_driveTrain
));
91
92
93
// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=SUBSYSTEM_DEFAULT_COMMAND
94
95
// Configure autonomous sendable chooser
96
// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=AUTONOMOUS
97
98
m_chooser
.
setDefaultOption
(
"Autonomous"
,
new
Autonomous
());
99
100
// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=AUTONOMOUS
101
102
SmartDashboard
.
putData
(
"Auto Mode"
,
m_chooser
);
103
}
104
105
public
static
RobotContainer
getInstance
()
{
106
return
m_robotContainer
;
107
}
108
109
/**
110
* Use this method to define your button->command mappings.  Buttons can be created by
111
* instantiating a {@link GenericHID} or one of its subclasses ({@link
112
* edu.wpi.first.wpilibj.Joystick} or {@link XboxController}), and then passing it to a
113
* {@link edu.wpi.first.wpilibj2.command.button.JoystickButton}.
114
*/
115
private
void
configureButtonBindings
()
{
116
// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=BUTTONS
117
// Create some buttons
118
final
JoystickButton
r1
=
new
JoystickButton
(
logitechController
,
12
);
119
r1
.
onTrue
(
new
SetWristSetpoint
(
0
,
m_elevator
).
withInterruptBehavior
(
InterruptionBehavior
.
kCancelSelf
));
120
121
final
JoystickButton
l1
=
new
JoystickButton
(
logitechController
,
11
);
122
l1
.
onTrue
(
new
Place
().
withInterruptBehavior
(
InterruptionBehavior
.
kCancelSelf
));
123
124
final
JoystickButton
r2
=
new
JoystickButton
(
logitechController
,
10
);
125
r2
.
onTrue
(
new
Pickup
().
withInterruptBehavior
(
InterruptionBehavior
.
kCancelSelf
));
126
127
final
JoystickButton
l2
=
new
JoystickButton
(
logitechController
,
9
);
128
l2
.
onTrue
(
new
PrepareToPickup
().
withInterruptBehavior
(
InterruptionBehavior
.
kCancelSelf
));
129
130
final
JoystickButton
dpadLeft
=
new
JoystickButton
(
logitechController
,
8
);
131
dpadLeft
.
onTrue
(
new
OpenClaw
(
0
).
withInterruptBehavior
(
InterruptionBehavior
.
kCancelSelf
));
132
133
final
JoystickButton
dpadRight
=
new
JoystickButton
(
logitechController
,
6
);
134
dpadRight
.
onTrue
(
new
CloseClaw
(
m_claw
).
withInterruptBehavior
(
InterruptionBehavior
.
kCancelSelf
));
135
136
final
JoystickButton
dpadDown
=
new
JoystickButton
(
logitechController
,
7
);
137
dpadDown
.
onTrue
(
new
SetElevatorSetpoint
(
2
,
m_elevator
).
withInterruptBehavior
(
InterruptionBehavior
.
kCancelSelf
));
138
139
final
JoystickButton
dpadUp
=
new
JoystickButton
(
logitechController
,
5
);
140
dpadUp
.
onTrue
(
new
SetElevatorSetpoint
(
2
,
m_elevator
).
withInterruptBehavior
(
InterruptionBehavior
.
kCancelSelf
));
141
142
143
144
// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=BUTTONS
145
}
146
147
// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=FUNCTIONS
148
public
Joystick
getLogitechController
()
{
149
return
logitechController
;
150
}
151
152
public
Joystick
getJoystick1
()
{
153
return
joystick1
;
154
}
155
156
public
Joystick
getJoystick2
()
{
157
return
joystick2
;
158
}
159
160
161
// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=FUNCTIONS
162
163
/**
164
* Use this to pass the autonomous command to the main {@link Robot} class.
165
*
166
* @return the command to run in autonomous
167
*/
168
public
Command
getAutonomousCommand
()
{
169
// The selected command will be run in autonomous
170
return
m_chooser
.
getSelected
();
171
}
172
173
174
}
C++ (Header)
11
// ROBOTBUILDER TYPE: RobotContainer.
12
13
#pragma once
14
15
// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES
16
#include
<frc/smartdashboard/SendableChooser.h>
17
#include
<frc2/command/Command.h>
18
19
#include
"subsystems/Claw.h"
20
#include
"subsystems/DriveTrain.h"
21
#include
"subsystems/Elevator.h"
22
#include
"subsystems/Wrist.h"
23
24
#include
"commands/Autonomous.h"
25
#include
"commands/CloseClaw.h"
26
#include
"commands/DriveAuto.h"
27
#include
"commands/OpenClaw.h"
28
#include
"commands/Pickup.h"
29
#include
"commands/Place.h"
30
#include
"commands/PrepareToPickup.h"
31
#include
"commands/SetElevatorSetpoint.h"
32
#include
"commands/SetWristSetpoint.h"
33
#include
"commands/TankDrive.h"
34
#include
<frc/Joystick.h>
35
#include
<frc2/command/button/JoystickButton.h>
36
37
// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES
38
39
class
RobotContainer
{
40
41
public
:
42
43
frc2
::
Command
*
GetAutonomousCommand
();
44
static
RobotContainer
*
GetInstance
();
45
46
// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=PROTOTYPES
47
// The robot's subsystems
48
DriveTrain
m_driveTrain
;
49
Claw
m_claw
;
50
Elevator
m_elevator
;
51
Wrist
m_wrist
;
52
53
54
frc
::
Joystick
*
getJoystick2
();
55
frc
::
Joystick
*
getJoystick1
();
56
frc
::
Joystick
*
getLogitechController
();
57
58
// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=PROTOTYPES
59
60
private
:
61
62
RobotContainer
();
63
64
// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
65
// Joysticks
66
frc
::
Joystick
m_logitechController
{
0
};
67
frc
::
Joystick
m_joystick1
{
1
};
68
frc
::
Joystick
m_joystick2
{
2
};
69
70
frc
::
SendableChooser
<
frc2
::
Command
*>
m_chooser
;
71
72
// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
73
74
static
RobotContainer
*
m_robotContainer
;
75
76
void
ConfigureButtonBindings
();
77
};
C++ (Source)
11
// ROBOTBUILDER TYPE: RobotContainer.
12
13
#include
"RobotContainer.h"
14
#include
<frc2/command/ParallelRaceGroup.h>
15
#include
<frc/smartdashboard/SmartDashboard.h>
16
17
18
19
RobotContainer
*
RobotContainer
::
m_robotContainer
=
NULL
;
20
21
RobotContainer
::
RobotContainer
(){
22
// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTOR
23
24
25
// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTOR
26
27
// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=SMARTDASHBOARD
28
// Smartdashboard Subsystems
29
frc
::
SmartDashboard
::
PutData
(
&
m_driveTrain
);
30
frc
::
SmartDashboard
::
PutData
(
&
m_claw
);
31
frc
::
SmartDashboard
::
PutData
(
&
m_elevator
);
32
frc
::
SmartDashboard
::
PutData
(
&
m_wrist
);
33
34
35
// SmartDashboard Buttons
36
frc
::
SmartDashboard
::
PutData
(
"DriveAuto: default"
,
new
DriveAuto
(
10
,
0
));
37
frc
::
SmartDashboard
::
PutData
(
"Tank Drive: joystick"
,
new
TankDrive
([
this
]
{
return
getJoystick1
()
->
GetY
();},
[
this
]
{
return
getJoystick2
()
->
GetY
();},
&
m_driveTrain
));
38
frc
::
SmartDashboard
::
PutData
(
"Set Wrist Setpoint: Horizontal"
,
new
SetWristSetpoint
(
0
,
&
m_elevator
));
39
frc
::
SmartDashboard
::
PutData
(
"Set Wrist Setpoint: Raise Wrist"
,
new
SetWristSetpoint
(
-45
,
&
m_elevator
));
40
frc
::
SmartDashboard
::
PutData
(
"Set Elevator Setpoint: down"
,
new
SetElevatorSetpoint
(
1
,
&
m_elevator
));
41
frc
::
SmartDashboard
::
PutData
(
"Set Elevator Setpoint: up"
,
new
SetElevatorSetpoint
(
2
,
&
m_elevator
));
42
frc
::
SmartDashboard
::
PutData
(
"Prepare To Pickup"
,
new
PrepareToPickup
());
43
frc
::
SmartDashboard
::
PutData
(
"Place"
,
new
Place
());
44
frc
::
SmartDashboard
::
PutData
(
"Pickup"
,
new
Pickup
());
45
frc
::
SmartDashboard
::
PutData
(
"Open Claw: default"
,
new
OpenClaw
(
1
_s
));
46
frc
::
SmartDashboard
::
PutData
(
"Close Claw"
,
new
CloseClaw
(
&
m_claw
));
47
48
// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=SMARTDASHBOARD
49
50
ConfigureButtonBindings
();
51
52
// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT-COMMANDS
53
m_driveTrain
.
SetDefaultCommand
(
TankDrive
([
this
]
{
return
getJoystick1
()
->
GetY
();},
[
this
]
{
return
getJoystick2
()
->
GetY
();},
&
m_driveTrain
));
54
55
// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT-COMMANDS
56
57
// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=AUTONOMOUS
58
59
m_chooser
.
SetDefaultOption
(
"Autonomous"
,
new
Autonomous
());
60
61
// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=AUTONOMOUS
62
63
frc
::
SmartDashboard
::
PutData
(
"Auto Mode"
,
&
m_chooser
);
64
65
}
66
67
RobotContainer
*
RobotContainer
::
GetInstance
()
{
68
if
(
m_robotContainer
==
NULL
)
{
69
m_robotContainer
=
new
RobotContainer
();
70
}
71
return
(
m_robotContainer
);
72
}
73
74
void
RobotContainer
::
ConfigureButtonBindings
()
{
75
// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=BUTTONS
76
77
frc2
::
JoystickButton
m_dpadUp
{
&
m_logitechController
,
5
};
78
frc2
::
JoystickButton
m_dpadDown
{
&
m_logitechController
,
7
};
79
frc2
::
JoystickButton
m_dpadRight
{
&
m_logitechController
,
6
};
80
frc2
::
JoystickButton
m_dpadLeft
{
&
m_logitechController
,
8
};
81
frc2
::
JoystickButton
m_l2
{
&
m_logitechController
,
9
};
82
frc2
::
JoystickButton
m_r2
{
&
m_logitechController
,
10
};
83
frc2
::
JoystickButton
m_l1
{
&
m_logitechController
,
11
};
84
frc2
::
JoystickButton
m_r1
{
&
m_logitechController
,
12
};
85
86
m_dpadUp
.
OnTrue
(
SetElevatorSetpoint
(
2
,
&
m_elevator
).
WithInterruptBehavior
(
frc2
::
Command
::
InterruptionBehavior
::
kCancelSelf
));
87
88
m_dpadDown
.
OnTrue
(
SetElevatorSetpoint
(
2
,
&
m_elevator
).
WithInterruptBehavior
(
frc2
::
Command
::
InterruptionBehavior
::
kCancelSelf
));
89
90
m_dpadRight
.
OnTrue
(
CloseClaw
(
&
m_claw
).
WithInterruptBehavior
(
frc2
::
Command
::
InterruptionBehavior
::
kCancelSelf
));
91
92
m_dpadLeft
.
OnTrue
(
OpenClaw
(
0
_s
).
WithInterruptBehavior
(
frc2
::
Command
::
InterruptionBehavior
::
kCancelSelf
));
93
94
m_l2
.
OnTrue
(
PrepareToPickup
().
WithInterruptBehavior
(
frc2
::
Command
::
InterruptionBehavior
::
kCancelSelf
));
95
96
m_r2
.
OnTrue
(
Pickup
().
WithInterruptBehavior
(
frc2
::
Command
::
InterruptionBehavior
::
kCancelSelf
));
97
98
m_l1
.
OnTrue
(
Place
().
WithInterruptBehavior
(
frc2
::
Command
::
InterruptionBehavior
::
kCancelSelf
));
99
100
m_r1
.
OnTrue
(
SetWristSetpoint
(
0
,
&
m_elevator
).
WithInterruptBehavior
(
frc2
::
Command
::
InterruptionBehavior
::
kCancelSelf
));
101
102
103
// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=BUTTONS
104
}
105
106
// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=FUNCTIONS
107
108
frc
::
Joystick
*
RobotContainer
::
getLogitechController
()
{
109
return
&
m_logitechController
;
110
}
111
frc
::
Joystick
*
RobotContainer
::
getJoystick1
()
{
112
return
&
m_joystick1
;
113
}
114
frc
::
Joystick
*
RobotContainer
::
getJoystick2
()
{
115
return
&
m_joystick2
;
116
}
117
118
// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=FUNCTIONS
119
120
121
frc2
::
Command
*
RobotContainer
::
GetAutonomousCommand
()
{
122
// The selected command will be run in autonomous
123
return
m_chooser
.
GetSelected
();
124
}
This is the RobotContainer generated by RobotBuilder which is where the subsystems and operator interface are defined. There are a number of parts to this program (highlighted sections):
Each of the subsystems is declared here. They can be passed as parameters to any commands that require them.
If there is an autonomous command provided in RobotBuilder robot properties, it is added to the Sendable Chooser to be selected on the dashboard.
The code for all the operator interface components is generated here.
In addition the code to link the OI buttons to commands that should run is also generated here.
Commands to be run on a subsystem when no other commands are running are defined here.
Commands to be run via a dashboard are defined here.