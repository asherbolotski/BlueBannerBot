REVLib
REVLib
Installation
Changelog
REVLib Code Examples (GitHub)
Migrating to REVLib 2025
Configuring Devices
Retrieving Configurations
Flexibility with Configurations
SPARK Motor Controllers
SPARK MAX vs SPARK Flex
Configuring a SPARK
Closed Loop Control
Closed Loop Control Getting Started
Getting Started with PID Tuning
Position Control Mode
Velocity Control Mode
Current Control Mode
MAXMotion Position Control
MAXMotion Velocity Control
Smart Motion Control
Smart Velocity Control
Simulation
Simulation Getting Started
REVLib Simulation Feature Overview
Simulating Additional Sensors and Auxiliary Devices
Servo Hub
Configuring a Servo Hub
Commanding Servos
Powered by GitBook
On this page
WPILib Simulation Tools
Simulating Spark MAX and Flex devices
Making Them Move
Where to now?
Was this helpful?
Export as PDF
WPILib Simulation Tools
In WPILib VSCode, running a robot code simulation is easy: click the WPILib icon in the top right corner of the UI and select 'Simulate Robot Code'. This will compile your code and launch the Simulation GUI, which displays controls and data during your simulation.
You may be prompted to enable Desktop support for your project, especially if you are using C++, or you may need to manually enable it if features don't work as expected. This can be changed by clicking the WPILib logo and selecting 'Change Desktop Support Enabled Setting'.
The Simulation GUI
Once your simulation is running, you'll be prompted to use the Simulation GUI or the normal driver station for simulation control. The Sim GUI has many helpful interfaces all in one place, like the NetworkTables GUI and Other Devices display, so that's what we'll cover here.
To access the Other Devices display, shown on the right, open it via Hardware > Other Devices at the top of the screen. These drop down interfaces are generated by your code and will contain the list of applicable devices, without any simulation-specific code needed.
The GUI in the center contains the NetworkTables, the one at the top left controls enable/disable state, and the one at the bottom left controls joystick order. These give you basic control over the simulation and how you want to interface with it and outputs like you'd see during a match. You can even use a keyboard to emulate a controller if you don't have one! For more information on other elements,
see the WPILib Docs
.
Simulating Spark MAX and Flex devices
Without any simulation-specific code, your Spark devices will still offer some simulation features. Parameters and settings will be able to be set and retrieved, the setpoint and control mode can be set, and the simulation GUI will reflect all of these changes. However, additional code is required to update the applied output or position/velocity and to access the more complex features of the simulation.
As shown below, both the Spark Flex and Spark MAX have Sim classes, which give you full control over the devices and give you access to the methods needed to update the output of the simulated motor controllers.
Java
C++
Copy
// create the DCMotor objects to specify the motor type
DCMotor maxGearbox = DCMotor.getNEO(1);
// multiple motors attached to the same gearbox in follower mode should be
// simulated as one motor
DCMotor flexGearbox = DCMotor.getNeoVortex(2);
// create the normal Spark MAX object
SparkMax max = new SparkMAX(10, MotorType.kBrushless);
// create the Spark MAX sim object
SparkMaxSim maxSim = new SparkMaxSim(max, maxGearbox);
// create the normal Spark Flex object
SparkFlex flex = new SparkFlex(11, MotorType.kBrushless);
// create the Spark Flex sim object
SparkFlexSim flexSim = new SparkFlexSim(flex, flexGearbox);
Copy
using namespace frc;
using namespace rev::spark;
// create the DCMotor objects to specify the motor type
DCMotor maxGearbox = DCMotor::NEO(1);
// multiple motors attached to the same gearbox in follower mode should be
// simulated as one motor
DCMotor flexGearbox = DCMotor::NeoVortex(2);
// create the normal Spark MAX object
SparkMax max{10, SparkMax::MotorType::kBrushless};
// create the Spark MAX sim object
SparkMaxSim maxSim{&max, &maxGearbox};
// create the normal Spark Flex object
SparkFlex flex{11, SparkFlex::MotorType::kBrushless};
// create the Spark Flex sim object
SparkFlexSim flexSim{&flex, &flexGearbox};
With these Spark sim objects, you can read and write many fields within the simulation, like manually setting the position, velocity, or motor temperature. The values you set will be visible in the sim GUI and will also be returned by the native functions to get these values in your robot code.
Making Them Move
These Spark sim objects also have a method, called .iterate, that will simulate many of the features of the motor controller and allow you to simulate the motion of the motor with the help of a WPILib physics simulation.
WPILib Physics Models
WPILib offers a number of premade physics models of common FRC systems
. These will help us simulate the motion of a motor, as they handle the underlying physics of the load of the motor. Selecting a model and filling out the appropriate fields to describe your physical system will make the simulation as close to real life as possible. These values can be calculated from a CAD model, or measured on a robot.
Putting them together
During a simulation, the physics model takes in the voltage applied to the motor and returns the velocity with which the motor is rotating. The Spark sim's .iterate method takes in the velocity of the motor from the physics model, the bus voltage (supply voltage to the controller), and the time interval for calculations (0.02 seconds, unless you want to track time differently), and updates all the fields of the Spark sim and native Spark to reflect the new state. An example with a simulated arm and a Spark Flex is shown below, but the Spark MAX behavior is the same and the Arm system could be substituted for another WPILib model.
Java
C++
Copy
public void simulationPeriodic() {
// In this method, we update our simulation of what our arm is doing
// First, we set our "inputs" (voltages)
m_armSim.setInput(m_motorSim.getAppliedOutput() * RoboRioSim.getVInVoltage());
// Next, we update it. The standard loop time is 20ms.
m_armSim.update(0.02);
// Now, we update the Spark Flex
flexSim.iterate(
Units.radiansPerSecondToRotationsPerMinute( // motor velocity, in RPM
m_armSim.getVelocityRadPerSec()),
RoboRioSim.getVInVoltage(), // Simulated battery voltage, in Volts
0.02); // Time interval, in Seconds
// SimBattery estimates loaded battery voltages
// This should include all motors being simulated
RoboRioSim.setVInVoltage(
BatterySim.calculateDefaultBatteryLoadedVoltage(m_armSim.getCurrentDrawAmps()));
// Update any external GUI displays or values as desired
// For example, a Mechanism2d Arm based on the simulated arm angle
m_arm.setAngle(Units.radiansToDegrees(m_armSim.getAngleRads()));
}
Copy
using namespace frc;
void Arm::SimulationPeriodic() {
// In this method, we update our simulation of what our arm is doing
// First, we set our "inputs" (voltages)
m_armSim.SetInput(
Vectord<1>{flexSim.getAppliedOutput() * RobotController::GetInputVoltage()});
// Next, we update it. The standard loop time is 20ms.
m_armSim.update(0.020);
// Now, we update the Spark Flex
flexSim.iterate(
units::revolutions_per_minute_t( // motor velocity, in RPM
m_armSim.getVelocity()).to<double>(),
RoboRioSim.getVInVoltage(), // Simulated battery voltage, in Volts
0.02); // Time interval, in Seconds
// SimBattery estimates loaded battery voltages
// This should include all motors being simulated
sim::RoboRioSim::SetVInVoltage(
sim::BatterySim::Calculate({m_armSim.GetCurrentDraw()}));
// Update any external GUI displays or values as desired
// For example, a Mechanism2d Arm based on the simulated arm angle
m_arm->SetAngle(m_armSim.GetAngle());
}
Where to now?
To see the full list of features, check out
REVLib Simulation Feature Overview
To simulate sensors and auxiliary devices, see
Simulating Additional Sensors and Auxiliary Devices
Previous
Simulation
Next
REVLib Simulation Feature Overview
Last updated
7 months ago
Was this helpful?