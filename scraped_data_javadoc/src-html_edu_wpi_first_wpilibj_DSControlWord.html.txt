001
// Copyright (c) FIRST and other WPILib contributors.
002
// Open Source Software; you can modify and/or share it under the terms of
003
// the WPILib BSD license file in the root directory of this project.
004
005
package edu.wpi.first.wpilibj;
006
007
import edu.wpi.first.hal.ControlWord;
008
009
/** A wrapper around Driver Station control word. */
010
public class DSControlWord {
011
private final ControlWord m_controlWord = new ControlWord();
012
013
/**
014
* DSControlWord constructor.
015
*
016
* <p>Upon construction, the current Driver Station control word is read and stored internally.
017
*/
018
public DSControlWord() {
019
refresh();
020
}
021
022
/** Update internal Driver Station control word. */
023
public final void refresh() {
024
DriverStation.refreshControlWordFromCache(m_controlWord);
025
}
026
027
/**
028
* Gets a value indicating whether the Driver Station requires the robot to be enabled.
029
*
030
* @return True if the robot is enabled, false otherwise.
031
*/
032
public boolean isEnabled() {
033
return m_controlWord.getEnabled() && m_controlWord.getDSAttached();
034
}
035
036
/**
037
* Gets a value indicating whether the Driver Station requires the robot to be disabled.
038
*
039
* @return True if the robot should be disabled, false otherwise.
040
*/
041
public boolean isDisabled() {
042
return !isEnabled();
043
}
044
045
/**
046
* Gets a value indicating whether the Robot is e-stopped.
047
*
048
* @return True if the robot is e-stopped, false otherwise.
049
*/
050
public boolean isEStopped() {
051
return m_controlWord.getEStop();
052
}
053
054
/**
055
* Gets a value indicating whether the Driver Station requires the robot to be running in
056
* autonomous mode.
057
*
058
* @return True if autonomous mode should be enabled, false otherwise.
059
*/
060
public boolean isAutonomous() {
061
return m_controlWord.getAutonomous();
062
}
063
064
/**
065
* Gets a value indicating whether the Driver Station requires the robot to be running in
066
* autonomous mode and enabled.
067
*
068
* @return True if autonomous should be set and the robot should be enabled.
069
*/
070
public boolean isAutonomousEnabled() {
071
return m_controlWord.getAutonomous()
072
&& m_controlWord.getEnabled()
073
&& m_controlWord.getDSAttached();
074
}
075
076
/**
077
* Gets a value indicating whether the Driver Station requires the robot to be running in
078
* operator-controlled mode.
079
*
080
* @return True if operator-controlled mode should be enabled, false otherwise.
081
*/
082
public boolean isTeleop() {
083
return !(isAutonomous() || isTest());
084
}
085
086
/**
087
* Gets a value indicating whether the Driver Station requires the robot to be running in
088
* operator-controller mode and enabled.
089
*
090
* @return True if operator-controlled mode should be set and the robot should be enabled.
091
*/
092
public boolean isTeleopEnabled() {
093
return !m_controlWord.getAutonomous()
094
&& !m_controlWord.getTest()
095
&& m_controlWord.getEnabled()
096
&& m_controlWord.getDSAttached();
097
}
098
099
/**
100
* Gets a value indicating whether the Driver Station requires the robot to be running in test
101
* mode.
102
*
103
* @return True if test mode should be enabled, false otherwise.
104
*/
105
public boolean isTest() {
106
return m_controlWord.getTest();
107
}
108
109
/**
110
* Gets a value indicating whether the Driver Station is attached.
111
*
112
* @return True if Driver Station is attached, false otherwise.
113
*/
114
public boolean isDSAttached() {
115
return m_controlWord.getDSAttached();
116
}
117
118
/**
119
* Gets if the driver station attached to a Field Management System.
120
*
121
* @return true if the robot is competing on a field being controlled by a Field Management System
122
*/
123
public boolean isFMSAttached() {
124
return m_controlWord.getFMSAttached();
125
}
126
}