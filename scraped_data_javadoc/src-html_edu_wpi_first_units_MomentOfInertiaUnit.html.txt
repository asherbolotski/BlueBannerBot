001
// Copyright (c) FIRST and other WPILib contributors.
002
// Open Source Software; you can modify and/or share it under the terms of
003
// the WPILib BSD license file in the root directory of this project.
004
005
package edu.wpi.first.units;
006
007
import edu.wpi.first.units.measure.ImmutableMomentOfInertia;
008
import edu.wpi.first.units.measure.MomentOfInertia;
009
import edu.wpi.first.units.measure.MutMomentOfInertia;
010
011
/**
012
* A unit of moment of inertia, like {@link edu.wpi.first.units.Units#KilogramSquareMeters}. Moments
013
* of inertia describe how much an object resists being rotated, analogous to mass's resistance to
014
* being accelerated along a line.
015
*/
016
public final class MomentOfInertiaUnit extends PerUnit<AngularMomentumUnit, AngularVelocityUnit> {
017
private static final CombinatoryUnitCache<
018
AngularMomentumUnit, AngularVelocityUnit, MomentOfInertiaUnit>
019
cache = new CombinatoryUnitCache<>(MomentOfInertiaUnit::new);
020
021
MomentOfInertiaUnit(AngularMomentumUnit numerator, AngularVelocityUnit denominator) {
022
super(
023
numerator.isBaseUnit() && denominator.isBaseUnit()
024
? null
025
: combine(numerator.getBaseUnit(), denominator.getBaseUnit()),
026
numerator,
027
denominator);
028
}
029
030
MomentOfInertiaUnit(
031
MomentOfInertiaUnit baseUnit,
032
UnaryFunction toBaseConverter,
033
UnaryFunction fromBaseConverter,
034
String name,
035
String symbol) {
036
super(baseUnit, toBaseConverter, fromBaseConverter, name, symbol);
037
}
038
039
/**
040
* Combines an angular momentum and angular velocity unit to form a moment of inertia unit.
041
*
042
* @param momentumUnit the unit of angular momentum
043
* @param velocityUnit the unit of angular velocity
044
* @return the combined moment of inertia unit
045
*/
046
public static MomentOfInertiaUnit combine(
047
AngularMomentumUnit momentumUnit, AngularVelocityUnit velocityUnit) {
048
return cache.combine(momentumUnit, velocityUnit);
049
}
050
051
@Override
052
public MomentOfInertiaUnit getBaseUnit() {
053
return (MomentOfInertiaUnit) super.getBaseUnit();
054
}
055
056
@Override
057
public MomentOfInertia of(double magnitude) {
058
return new ImmutableMomentOfInertia(magnitude, toBaseUnits(magnitude), this);
059
}
060
061
@Override
062
public MomentOfInertia ofBaseUnits(double baseUnitMagnitude) {
063
return new ImmutableMomentOfInertia(fromBaseUnits(baseUnitMagnitude), baseUnitMagnitude, this);
064
}
065
066
@Override
067
public MomentOfInertia zero() {
068
return (MomentOfInertia) super.zero();
069
}
070
071
@Override
072
public MomentOfInertia one() {
073
return (MomentOfInertia) super.one();
074
}
075
076
@Override
077
public MutMomentOfInertia mutable(double initialMagnitude) {
078
return new MutMomentOfInertia(initialMagnitude, toBaseUnits(initialMagnitude), this);
079
}
080
081
@Override
082
public VelocityUnit<MomentOfInertiaUnit> per(TimeUnit time) {
083
return VelocityUnit.combine(this, time);
084
}
085
086
/**
087
* Creates a ratio unit between this unit and an arbitrary other unit.
088
*
089
* @param other the other unit
090
* @param <U> the type of the other unit
091
* @return the ratio unit
092
*/
093
public <U extends Unit> PerUnit<MomentOfInertiaUnit, U> per(U other) {
094
return PerUnit.combine(this, other);
095
}
096
097
/**
098
* Converts a measurement value in terms of another unit to this unit.
099
*
100
* @param magnitude the magnitude of the measurement in terms of the other unit
101
* @param otherUnit the other unit
102
* @return the value of the measurement in terms of this unit
103
*/
104
public double convertFrom(double magnitude, MomentOfInertiaUnit otherUnit) {
105
return fromBaseUnits(otherUnit.toBaseUnits(magnitude));
106
}
107
}