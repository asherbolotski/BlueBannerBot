001
// Copyright (c) FIRST and other WPILib contributors.
002
// Open Source Software; you can modify and/or share it under the terms of
003
// the WPILib BSD license file in the root directory of this project.
004
// Code generated by protocol buffer compiler. Do not edit!
005
package edu.wpi.first.math.proto;
006
007
import java.io.IOException;
008
import us.hebi.quickbuf.Descriptors;
009
import us.hebi.quickbuf.FieldName;
010
import us.hebi.quickbuf.InvalidProtocolBufferException;
011
import us.hebi.quickbuf.JsonSink;
012
import us.hebi.quickbuf.JsonSource;
013
import us.hebi.quickbuf.MessageFactory;
014
import us.hebi.quickbuf.ProtoMessage;
015
import us.hebi.quickbuf.ProtoSink;
016
import us.hebi.quickbuf.ProtoSource;
017
import us.hebi.quickbuf.ProtoUtil;
018
import us.hebi.quickbuf.RepeatedByte;
019
import us.hebi.quickbuf.RepeatedDouble;
020
021
public final class Wpimath {
022
private static final RepeatedByte descriptorData = ProtoUtil.decodeBase64(540,
023
"Cg13cGltYXRoLnByb3RvEgl3cGkucHJvdG8iWgoOUHJvdG9idWZNYXRyaXgSGQoIbnVtX3Jvd3MYASAB" +
024
"KA1SB251bVJvd3MSGQoIbnVtX2NvbHMYAiABKA1SB251bUNvbHMSEgoEZGF0YRgDIAMoAVIEZGF0YSIk" +
025
"Cg5Qcm90b2J1ZlZlY3RvchISCgRyb3dzGAEgAygBUgRyb3dzQhoKGGVkdS53cGkuZmlyc3QubWF0aC5w" +
026
"cm90b0rZAgoGEgQAAA4BCggKAQwSAwAAEgoICgECEgMCABIKCAoBCBIDBAAxCgkKAggBEgMEADEKCgoC" +
027
"BAASBAYACgEKCgoDBAABEgMGCBYKCwoEBAACABIDBwIWCgwKBQQAAgAFEgMHAggKDAoFBAACAAESAwcJ" +
028
"EQoMCgUEAAIAAxIDBxQVCgsKBAQAAgESAwgCFgoMCgUEAAIBBRIDCAIICgwKBQQAAgEBEgMICREKDAoF" +
029
"BAACAQMSAwgUFQoLCgQEAAICEgMJAhsKDAoFBAACAgQSAwkCCgoMCgUEAAICBRIDCQsRCgwKBQQAAgIB" +
030
"EgMJEhYKDAoFBAACAgMSAwkZGgoKCgIEARIEDAAOAQoKCgMEAQESAwwIFgoLCgQEAQIAEgMNAhsKDAoF" +
031
"BAECAAQSAw0CCgoMCgUEAQIABRIDDQsRCgwKBQQBAgABEgMNEhYKDAoFBAECAAMSAw0ZGmIGcHJvdG8z");
032
033
static final Descriptors.FileDescriptor descriptor = Descriptors.FileDescriptor.internalBuildGeneratedFileFrom("wpimath.proto", "wpi.proto", descriptorData);
034
035
static final Descriptors.Descriptor wpi_proto_ProtobufMatrix_descriptor = descriptor.internalContainedType(28, 90, "ProtobufMatrix", "wpi.proto.ProtobufMatrix");
036
037
static final Descriptors.Descriptor wpi_proto_ProtobufVector_descriptor = descriptor.internalContainedType(120, 36, "ProtobufVector", "wpi.proto.ProtobufVector");
038
039
/**
040
* @return this proto file's descriptor.
041
*/
042
public static Descriptors.FileDescriptor getDescriptor() {
043
return descriptor;
044
}
045
046
/**
047
* Protobuf type {@code ProtobufMatrix}
048
*/
049
public static final class ProtobufMatrix extends ProtoMessage<ProtobufMatrix> implements Cloneable {
050
private static final long serialVersionUID = 0L;
051
052
/**
053
* <code>optional uint32 num_rows = 1;</code>
054
*/
055
private int numRows;
056
057
/**
058
* <code>optional uint32 num_cols = 2;</code>
059
*/
060
private int numCols;
061
062
/**
063
* <code>repeated double data = 3;</code>
064
*/
065
private final RepeatedDouble data = RepeatedDouble.newEmptyInstance();
066
067
private ProtobufMatrix() {
068
}
069
070
/**
071
* @return a new empty instance of {@code ProtobufMatrix}
072
*/
073
public static ProtobufMatrix newInstance() {
074
return new ProtobufMatrix();
075
}
076
077
/**
078
* <code>optional uint32 num_rows = 1;</code>
079
* @return whether the numRows field is set
080
*/
081
public boolean hasNumRows() {
082
return (bitField0_ & 0x00000001) != 0;
083
}
084
085
/**
086
* <code>optional uint32 num_rows = 1;</code>
087
* @return this
088
*/
089
public ProtobufMatrix clearNumRows() {
090
bitField0_ &= ~0x00000001;
091
numRows = 0;
092
return this;
093
}
094
095
/**
096
* <code>optional uint32 num_rows = 1;</code>
097
* @return the numRows
098
*/
099
public int getNumRows() {
100
return numRows;
101
}
102
103
/**
104
* <code>optional uint32 num_rows = 1;</code>
105
* @param value the numRows to set
106
* @return this
107
*/
108
public ProtobufMatrix setNumRows(final int value) {
109
bitField0_ |= 0x00000001;
110
numRows = value;
111
return this;
112
}
113
114
/**
115
* <code>optional uint32 num_cols = 2;</code>
116
* @return whether the numCols field is set
117
*/
118
public boolean hasNumCols() {
119
return (bitField0_ & 0x00000002) != 0;
120
}
121
122
/**
123
* <code>optional uint32 num_cols = 2;</code>
124
* @return this
125
*/
126
public ProtobufMatrix clearNumCols() {
127
bitField0_ &= ~0x00000002;
128
numCols = 0;
129
return this;
130
}
131
132
/**
133
* <code>optional uint32 num_cols = 2;</code>
134
* @return the numCols
135
*/
136
public int getNumCols() {
137
return numCols;
138
}
139
140
/**
141
* <code>optional uint32 num_cols = 2;</code>
142
* @param value the numCols to set
143
* @return this
144
*/
145
public ProtobufMatrix setNumCols(final int value) {
146
bitField0_ |= 0x00000002;
147
numCols = value;
148
return this;
149
}
150
151
/**
152
* <code>repeated double data = 3;</code>
153
* @return whether the data field is set
154
*/
155
public boolean hasData() {
156
return (bitField0_ & 0x00000004) != 0;
157
}
158
159
/**
160
* <code>repeated double data = 3;</code>
161
* @return this
162
*/
163
public ProtobufMatrix clearData() {
164
bitField0_ &= ~0x00000004;
165
data.clear();
166
return this;
167
}
168
169
/**
170
* <code>repeated double data = 3;</code>
171
*
172
* This method returns the internal storage object without modifying any has state.
173
* The returned object should not be modified and be treated as read-only.
174
*
175
* Use {@link #getMutableData()} if you want to modify it.
176
*
177
* @return internal storage object for reading
178
*/
179
public RepeatedDouble getData() {
180
return data;
181
}
182
183
/**
184
* <code>repeated double data = 3;</code>
185
*
186
* This method returns the internal storage object and sets the corresponding
187
* has state. The returned object will become part of this message and its
188
* contents may be modified as long as the has state is not cleared.
189
*
190
* @return internal storage object for modifications
191
*/
192
public RepeatedDouble getMutableData() {
193
bitField0_ |= 0x00000004;
194
return data;
195
}
196
197
/**
198
* <code>repeated double data = 3;</code>
199
* @param value the data to add
200
* @return this
201
*/
202
public ProtobufMatrix addData(final double value) {
203
bitField0_ |= 0x00000004;
204
data.add(value);
205
return this;
206
}
207
208
/**
209
* <code>repeated double data = 3;</code>
210
* @param values the data to add
211
* @return this
212
*/
213
public ProtobufMatrix addAllData(final double... values) {
214
bitField0_ |= 0x00000004;
215
data.addAll(values);
216
return this;
217
}
218
219
@Override
220
public ProtobufMatrix copyFrom(final ProtobufMatrix other) {
221
cachedSize = other.cachedSize;
222
if ((bitField0_ | other.bitField0_) != 0) {
223
bitField0_ = other.bitField0_;
224
numRows = other.numRows;
225
numCols = other.numCols;
226
data.copyFrom(other.data);
227
}
228
return this;
229
}
230
231
@Override
232
public ProtobufMatrix mergeFrom(final ProtobufMatrix other) {
233
if (other.isEmpty()) {
234
return this;
235
}
236
cachedSize = -1;
237
if (other.hasNumRows()) {
238
setNumRows(other.numRows);
239
}
240
if (other.hasNumCols()) {
241
setNumCols(other.numCols);
242
}
243
if (other.hasData()) {
244
getMutableData().addAll(other.data);
245
}
246
return this;
247
}
248
249
@Override
250
public ProtobufMatrix clear() {
251
if (isEmpty()) {
252
return this;
253
}
254
cachedSize = -1;
255
bitField0_ = 0;
256
numRows = 0;
257
numCols = 0;
258
data.clear();
259
return this;
260
}
261
262
@Override
263
public ProtobufMatrix clearQuick() {
264
if (isEmpty()) {
265
return this;
266
}
267
cachedSize = -1;
268
bitField0_ = 0;
269
data.clear();
270
return this;
271
}
272
273
@Override
274
public boolean equals(Object o) {
275
if (o == this) {
276
return true;
277
}
278
if (!(o instanceof ProtobufMatrix)) {
279
return false;
280
}
281
ProtobufMatrix other = (ProtobufMatrix) o;
282
return bitField0_ == other.bitField0_
283
&& (!hasNumRows() || numRows == other.numRows)
284
&& (!hasNumCols() || numCols == other.numCols)
285
&& (!hasData() || data.equals(other.data));
286
}
287
288
@Override
289
public void writeTo(final ProtoSink output) throws IOException {
290
if ((bitField0_ & 0x00000001) != 0) {
291
output.writeRawByte((byte) 8);
292
output.writeUInt32NoTag(numRows);
293
}
294
if ((bitField0_ & 0x00000002) != 0) {
295
output.writeRawByte((byte) 16);
296
output.writeUInt32NoTag(numCols);
297
}
298
if ((bitField0_ & 0x00000004) != 0) {
299
for (int i = 0; i < data.length(); i++) {
300
output.writeRawByte((byte) 25);
301
output.writeDoubleNoTag(data.array()[i]);
302
}
303
}
304
}
305
306
@Override
307
protected int computeSerializedSize() {
308
int size = 0;
309
if ((bitField0_ & 0x00000001) != 0) {
310
size += 1 + ProtoSink.computeUInt32SizeNoTag(numRows);
311
}
312
if ((bitField0_ & 0x00000002) != 0) {
313
size += 1 + ProtoSink.computeUInt32SizeNoTag(numCols);
314
}
315
if ((bitField0_ & 0x00000004) != 0) {
316
size += (1 + 8) * data.length();
317
}
318
return size;
319
}
320
321
@Override
322
@SuppressWarnings("fallthrough")
323
public ProtobufMatrix mergeFrom(final ProtoSource input) throws IOException {
324
// Enabled Fall-Through Optimization (QuickBuffers)
325
int tag = input.readTag();
326
while (true) {
327
switch (tag) {
328
case 8: {
329
// numRows
330
numRows = input.readUInt32();
331
bitField0_ |= 0x00000001;
332
tag = input.readTag();
333
if (tag != 16) {
334
break;
335
}
336
}
337
case 16: {
338
// numCols
339
numCols = input.readUInt32();
340
bitField0_ |= 0x00000002;
341
tag = input.readTag();
342
if (tag != 26) {
343
break;
344
}
345
}
346
case 26: {
347
// data [packed=true]
348
input.readPackedDouble(data);
349
bitField0_ |= 0x00000004;
350
tag = input.readTag();
351
if (tag != 0) {
352
break;
353
}
354
}
355
case 0: {
356
return this;
357
}
358
default: {
359
if (!input.skipField(tag)) {
360
return this;
361
}
362
tag = input.readTag();
363
break;
364
}
365
case 25: {
366
// data [packed=false]
367
tag = input.readRepeatedDouble(data, tag);
368
bitField0_ |= 0x00000004;
369
break;
370
}
371
}
372
}
373
}
374
375
@Override
376
public void writeTo(final JsonSink output) throws IOException {
377
output.beginObject();
378
if ((bitField0_ & 0x00000001) != 0) {
379
output.writeUInt32(FieldNames.numRows, numRows);
380
}
381
if ((bitField0_ & 0x00000002) != 0) {
382
output.writeUInt32(FieldNames.numCols, numCols);
383
}
384
if ((bitField0_ & 0x00000004) != 0) {
385
output.writeRepeatedDouble(FieldNames.data, data);
386
}
387
output.endObject();
388
}
389
390
@Override
391
public ProtobufMatrix mergeFrom(final JsonSource input) throws IOException {
392
if (!input.beginObject()) {
393
return this;
394
}
395
while (!input.isAtEnd()) {
396
switch (input.readFieldHash()) {
397
case -2000982401:
398
case -1888824590: {
399
if (input.isAtField(FieldNames.numRows)) {
400
if (!input.trySkipNullValue()) {
401
numRows = input.readUInt32();
402
bitField0_ |= 0x00000001;
403
}
404
} else {
405
input.skipUnknownField();
406
}
407
break;
408
}
409
case -2001429607:
410
case -1889271796: {
411
if (input.isAtField(FieldNames.numCols)) {
412
if (!input.trySkipNullValue()) {
413
numCols = input.readUInt32();
414
bitField0_ |= 0x00000002;
415
}
416
} else {
417
input.skipUnknownField();
418
}
419
break;
420
}
421
case 3076010: {
422
if (input.isAtField(FieldNames.data)) {
423
if (!input.trySkipNullValue()) {
424
input.readRepeatedDouble(data);
425
bitField0_ |= 0x00000004;
426
}
427
} else {
428
input.skipUnknownField();
429
}
430
break;
431
}
432
default: {
433
input.skipUnknownField();
434
break;
435
}
436
}
437
}
438
input.endObject();
439
return this;
440
}
441
442
@Override
443
public ProtobufMatrix clone() {
444
return new ProtobufMatrix().copyFrom(this);
445
}
446
447
@Override
448
public boolean isEmpty() {
449
return ((bitField0_) == 0);
450
}
451
452
public static ProtobufMatrix parseFrom(final byte[] data) throws
453
InvalidProtocolBufferException {
454
return ProtoMessage.mergeFrom(new ProtobufMatrix(), data).checkInitialized();
455
}
456
457
public static ProtobufMatrix parseFrom(final ProtoSource input) throws IOException {
458
return ProtoMessage.mergeFrom(new ProtobufMatrix(), input).checkInitialized();
459
}
460
461
public static ProtobufMatrix parseFrom(final JsonSource input) throws IOException {
462
return ProtoMessage.mergeFrom(new ProtobufMatrix(), input).checkInitialized();
463
}
464
465
/**
466
* @return factory for creating ProtobufMatrix messages
467
*/
468
public static MessageFactory<ProtobufMatrix> getFactory() {
469
return ProtobufMatrixFactory.INSTANCE;
470
}
471
472
/**
473
* @return this type's descriptor.
474
*/
475
public static Descriptors.Descriptor getDescriptor() {
476
return Wpimath.wpi_proto_ProtobufMatrix_descriptor;
477
}
478
479
private enum ProtobufMatrixFactory implements MessageFactory<ProtobufMatrix> {
480
INSTANCE;
481
482
@Override
483
public ProtobufMatrix create() {
484
return ProtobufMatrix.newInstance();
485
}
486
}
487
488
/**
489
* Contains name constants used for serializing JSON
490
*/
491
static class FieldNames {
492
static final FieldName numRows = FieldName.forField("numRows", "num_rows");
493
494
static final FieldName numCols = FieldName.forField("numCols", "num_cols");
495
496
static final FieldName data = FieldName.forField("data");
497
}
498
}
499
500
/**
501
* Protobuf type {@code ProtobufVector}
502
*/
503
public static final class ProtobufVector extends ProtoMessage<ProtobufVector> implements Cloneable {
504
private static final long serialVersionUID = 0L;
505
506
/**
507
* <code>repeated double rows = 1;</code>
508
*/
509
private final RepeatedDouble rows = RepeatedDouble.newEmptyInstance();
510
511
private ProtobufVector() {
512
}
513
514
/**
515
* @return a new empty instance of {@code ProtobufVector}
516
*/
517
public static ProtobufVector newInstance() {
518
return new ProtobufVector();
519
}
520
521
/**
522
* <code>repeated double rows = 1;</code>
523
* @return whether the rows field is set
524
*/
525
public boolean hasRows() {
526
return (bitField0_ & 0x00000001) != 0;
527
}
528
529
/**
530
* <code>repeated double rows = 1;</code>
531
* @return this
532
*/
533
public ProtobufVector clearRows() {
534
bitField0_ &= ~0x00000001;
535
rows.clear();
536
return this;
537
}
538
539
/**
540
* <code>repeated double rows = 1;</code>
541
*
542
* This method returns the internal storage object without modifying any has state.
543
* The returned object should not be modified and be treated as read-only.
544
*
545
* Use {@link #getMutableRows()} if you want to modify it.
546
*
547
* @return internal storage object for reading
548
*/
549
public RepeatedDouble getRows() {
550
return rows;
551
}
552
553
/**
554
* <code>repeated double rows = 1;</code>
555
*
556
* This method returns the internal storage object and sets the corresponding
557
* has state. The returned object will become part of this message and its
558
* contents may be modified as long as the has state is not cleared.
559
*
560
* @return internal storage object for modifications
561
*/
562
public RepeatedDouble getMutableRows() {
563
bitField0_ |= 0x00000001;
564
return rows;
565
}
566
567
/**
568
* <code>repeated double rows = 1;</code>
569
* @param value the rows to add
570
* @return this
571
*/
572
public ProtobufVector addRows(final double value) {
573
bitField0_ |= 0x00000001;
574
rows.add(value);
575
return this;
576
}
577
578
/**
579
* <code>repeated double rows = 1;</code>
580
* @param values the rows to add
581
* @return this
582
*/
583
public ProtobufVector addAllRows(final double... values) {
584
bitField0_ |= 0x00000001;
585
rows.addAll(values);
586
return this;
587
}
588
589
@Override
590
public ProtobufVector copyFrom(final ProtobufVector other) {
591
cachedSize = other.cachedSize;
592
if ((bitField0_ | other.bitField0_) != 0) {
593
bitField0_ = other.bitField0_;
594
rows.copyFrom(other.rows);
595
}
596
return this;
597
}
598
599
@Override
600
public ProtobufVector mergeFrom(final ProtobufVector other) {
601
if (other.isEmpty()) {
602
return this;
603
}
604
cachedSize = -1;
605
if (other.hasRows()) {
606
getMutableRows().addAll(other.rows);
607
}
608
return this;
609
}
610
611
@Override
612
public ProtobufVector clear() {
613
if (isEmpty()) {
614
return this;
615
}
616
cachedSize = -1;
617
bitField0_ = 0;
618
rows.clear();
619
return this;
620
}
621
622
@Override
623
public ProtobufVector clearQuick() {
624
if (isEmpty()) {
625
return this;
626
}
627
cachedSize = -1;
628
bitField0_ = 0;
629
rows.clear();
630
return this;
631
}
632
633
@Override
634
public boolean equals(Object o) {
635
if (o == this) {
636
return true;
637
}
638
if (!(o instanceof ProtobufVector)) {
639
return false;
640
}
641
ProtobufVector other = (ProtobufVector) o;
642
return bitField0_ == other.bitField0_
643
&& (!hasRows() || rows.equals(other.rows));
644
}
645
646
@Override
647
public void writeTo(final ProtoSink output) throws IOException {
648
if ((bitField0_ & 0x00000001) != 0) {
649
for (int i = 0; i < rows.length(); i++) {
650
output.writeRawByte((byte) 9);
651
output.writeDoubleNoTag(rows.array()[i]);
652
}
653
}
654
}
655
656
@Override
657
protected int computeSerializedSize() {
658
int size = 0;
659
if ((bitField0_ & 0x00000001) != 0) {
660
size += (1 + 8) * rows.length();
661
}
662
return size;
663
}
664
665
@Override
666
@SuppressWarnings("fallthrough")
667
public ProtobufVector mergeFrom(final ProtoSource input) throws IOException {
668
// Enabled Fall-Through Optimization (QuickBuffers)
669
int tag = input.readTag();
670
while (true) {
671
switch (tag) {
672
case 10: {
673
// rows [packed=true]
674
input.readPackedDouble(rows);
675
bitField0_ |= 0x00000001;
676
tag = input.readTag();
677
if (tag != 0) {
678
break;
679
}
680
}
681
case 0: {
682
return this;
683
}
684
default: {
685
if (!input.skipField(tag)) {
686
return this;
687
}
688
tag = input.readTag();
689
break;
690
}
691
case 9: {
692
// rows [packed=false]
693
tag = input.readRepeatedDouble(rows, tag);
694
bitField0_ |= 0x00000001;
695
break;
696
}
697
}
698
}
699
}
700
701
@Override
702
public void writeTo(final JsonSink output) throws IOException {
703
output.beginObject();
704
if ((bitField0_ & 0x00000001) != 0) {
705
output.writeRepeatedDouble(FieldNames.rows, rows);
706
}
707
output.endObject();
708
}
709
710
@Override
711
public ProtobufVector mergeFrom(final JsonSource input) throws IOException {
712
if (!input.beginObject()) {
713
return this;
714
}
715
while (!input.isAtEnd()) {
716
switch (input.readFieldHash()) {
717
case 3506649: {
718
if (input.isAtField(FieldNames.rows)) {
719
if (!input.trySkipNullValue()) {
720
input.readRepeatedDouble(rows);
721
bitField0_ |= 0x00000001;
722
}
723
} else {
724
input.skipUnknownField();
725
}
726
break;
727
}
728
default: {
729
input.skipUnknownField();
730
break;
731
}
732
}
733
}
734
input.endObject();
735
return this;
736
}
737
738
@Override
739
public ProtobufVector clone() {
740
return new ProtobufVector().copyFrom(this);
741
}
742
743
@Override
744
public boolean isEmpty() {
745
return ((bitField0_) == 0);
746
}
747
748
public static ProtobufVector parseFrom(final byte[] data) throws
749
InvalidProtocolBufferException {
750
return ProtoMessage.mergeFrom(new ProtobufVector(), data).checkInitialized();
751
}
752
753
public static ProtobufVector parseFrom(final ProtoSource input) throws IOException {
754
return ProtoMessage.mergeFrom(new ProtobufVector(), input).checkInitialized();
755
}
756
757
public static ProtobufVector parseFrom(final JsonSource input) throws IOException {
758
return ProtoMessage.mergeFrom(new ProtobufVector(), input).checkInitialized();
759
}
760
761
/**
762
* @return factory for creating ProtobufVector messages
763
*/
764
public static MessageFactory<ProtobufVector> getFactory() {
765
return ProtobufVectorFactory.INSTANCE;
766
}
767
768
/**
769
* @return this type's descriptor.
770
*/
771
public static Descriptors.Descriptor getDescriptor() {
772
return Wpimath.wpi_proto_ProtobufVector_descriptor;
773
}
774
775
private enum ProtobufVectorFactory implements MessageFactory<ProtobufVector> {
776
INSTANCE;
777
778
@Override
779
public ProtobufVector create() {
780
return ProtobufVector.newInstance();
781
}
782
}
783
784
/**
785
* Contains name constants used for serializing JSON
786
*/
787
static class FieldNames {
788
static final FieldName rows = FieldName.forField("rows");
789
}
790
}
791
}