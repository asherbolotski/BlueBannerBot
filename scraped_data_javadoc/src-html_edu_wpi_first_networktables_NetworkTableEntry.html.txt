001
// Copyright (c) FIRST and other WPILib contributors.
002
// Open Source Software; you can modify and/or share it under the terms of
003
// the WPILib BSD license file in the root directory of this project.
004
005
// THIS FILE WAS AUTO-GENERATED BY ./ntcore/generate_topics.py. DO NOT MODIFY
006
007
package edu.wpi.first.networktables;
008
009
import java.nio.ByteBuffer;
010
011
/**
012
* NetworkTables Entry.
013
*
014
* <p>For backwards compatibility, the NetworkTableEntry close() does not release the entry.
015
*/
016
@SuppressWarnings("UnnecessaryParentheses")
017
public final class NetworkTableEntry implements Publisher, Subscriber {
018
/**
019
* Construct from native handle.
020
*
021
* @param inst Instance
022
* @param handle Native handle
023
*/
024
public NetworkTableEntry(NetworkTableInstance inst, int handle) {
025
this(new Topic(inst, NetworkTablesJNI.getTopicFromHandle(handle)), handle);
026
}
027
028
/**
029
* Construct from native handle.
030
*
031
* @param topic Topic
032
* @param handle Native handle
033
*/
034
public NetworkTableEntry(Topic topic, int handle) {
035
m_topic = topic;
036
m_handle = handle;
037
}
038
039
@Override
040
public void close() {}
041
042
/**
043
* Determines if the native handle is valid.
044
*
045
* @return True if the native handle is valid, false otherwise.
046
*/
047
@Override
048
public boolean isValid() {
049
return m_handle != 0;
050
}
051
052
/**
053
* Gets the native handle for the entry.
054
*
055
* @return Native handle
056
*/
057
@Override
058
public int getHandle() {
059
return m_handle;
060
}
061
062
/**
063
* Gets the subscribed-to / published-to topic.
064
*
065
* @return Topic
066
*/
067
@Override
068
public Topic getTopic() {
069
return m_topic;
070
}
071
072
/**
073
* Gets the instance for the entry.
074
*
075
* @return Instance
076
*/
077
public NetworkTableInstance getInstance() {
078
return m_topic.getInstance();
079
}
080
081
/**
082
* Determines if the entry currently exists.
083
*
084
* @return True if the entry exists, false otherwise.
085
*/
086
@Override
087
public boolean exists() {
088
return NetworkTablesJNI.getType(m_handle) != 0;
089
}
090
091
/**
092
* Gets the name of the entry (the key).
093
*
094
* @return the entry's name
095
*/
096
public String getName() {
097
return NetworkTablesJNI.getEntryName(m_handle);
098
}
099
100
/**
101
* Gets the type of the entry.
102
*
103
* @return the entry's type
104
*/
105
public NetworkTableType getType() {
106
return NetworkTableType.getFromInt(NetworkTablesJNI.getType(m_handle));
107
}
108
109
/**
110
* Gets the last time the entry's value was changed.
111
*
112
* @return Entry last change time
113
*/
114
@Override
115
public long getLastChange() {
116
return NetworkTablesJNI.getEntryLastChange(m_handle);
117
}
118
119
/**
120
* Gets the entry's value. Returns a value with type NetworkTableType.kUnassigned if the value
121
* does not exist.
122
*
123
* @return the entry's value
124
*/
125
public NetworkTableValue getValue() {
126
return NetworkTablesJNI.getValue(m_handle);
127
}
128
129
/**
130
* Gets the entry's value as a boolean. If the entry does not exist or is of different type, it
131
* will return the default value.
132
*
133
* @param defaultValue the value to be returned if no value is found
134
* @return the entry's value or the given default value
135
*/
136
public boolean getBoolean(boolean defaultValue) {
137
return NetworkTablesJNI.getBoolean(m_handle, defaultValue);
138
}
139
140
/**
141
* Gets the entry's value as a long. If the entry does not exist or is of different type, it
142
* will return the default value.
143
*
144
* @param defaultValue the value to be returned if no value is found
145
* @return the entry's value or the given default value
146
*/
147
public long getInteger(long defaultValue) {
148
return NetworkTablesJNI.getInteger(m_handle, defaultValue);
149
}
150
151
/**
152
* Gets the entry's value as a float. If the entry does not exist or is of different type, it
153
* will return the default value.
154
*
155
* @param defaultValue the value to be returned if no value is found
156
* @return the entry's value or the given default value
157
*/
158
public float getFloat(float defaultValue) {
159
return NetworkTablesJNI.getFloat(m_handle, defaultValue);
160
}
161
162
/**
163
* Gets the entry's value as a double. If the entry does not exist or is of different type, it
164
* will return the default value.
165
*
166
* @param defaultValue the value to be returned if no value is found
167
* @return the entry's value or the given default value
168
*/
169
public double getDouble(double defaultValue) {
170
return NetworkTablesJNI.getDouble(m_handle, defaultValue);
171
}
172
173
/**
174
* Gets the entry's value as a String. If the entry does not exist or is of different type, it
175
* will return the default value.
176
*
177
* @param defaultValue the value to be returned if no value is found
178
* @return the entry's value or the given default value
179
*/
180
public String getString(String defaultValue) {
181
return NetworkTablesJNI.getString(m_handle, defaultValue);
182
}
183
184
/**
185
* Gets the entry's value as a byte[]. If the entry does not exist or is of different type, it
186
* will return the default value.
187
*
188
* @param defaultValue the value to be returned if no value is found
189
* @return the entry's value or the given default value
190
*/
191
public byte[] getRaw(byte[] defaultValue) {
192
return NetworkTablesJNI.getRaw(m_handle, defaultValue);
193
}
194
195
/**
196
* Gets the entry's value as a boolean[]. If the entry does not exist or is of different type, it
197
* will return the default value.
198
*
199
* @param defaultValue the value to be returned if no value is found
200
* @return the entry's value or the given default value
201
*/
202
public boolean[] getBooleanArray(boolean[] defaultValue) {
203
return NetworkTablesJNI.getBooleanArray(m_handle, defaultValue);
204
}
205
206
/**
207
* Gets the entry's value as a boolean array. If the entry does not exist or is of different type,
208
* it will return the default value.
209
*
210
* @param defaultValue the value to be returned if no value is found
211
* @return the entry's value or the given default value
212
*/
213
public Boolean[] getBooleanArray(Boolean[] defaultValue) {
214
return NetworkTableValue.fromNativeBooleanArray(
215
getBooleanArray(NetworkTableValue.toNativeBooleanArray(defaultValue)));
216
}
217
218
/**
219
* Gets the entry's value as a long[]. If the entry does not exist or is of different type, it
220
* will return the default value.
221
*
222
* @param defaultValue the value to be returned if no value is found
223
* @return the entry's value or the given default value
224
*/
225
public long[] getIntegerArray(long[] defaultValue) {
226
return NetworkTablesJNI.getIntegerArray(m_handle, defaultValue);
227
}
228
229
/**
230
* Gets the entry's value as a boolean array. If the entry does not exist or is of different type,
231
* it will return the default value.
232
*
233
* @param defaultValue the value to be returned if no value is found
234
* @return the entry's value or the given default value
235
*/
236
public Long[] getIntegerArray(Long[] defaultValue) {
237
return NetworkTableValue.fromNativeIntegerArray(
238
getIntegerArray(NetworkTableValue.toNativeIntegerArray(defaultValue)));
239
}
240
241
/**
242
* Gets the entry's value as a float[]. If the entry does not exist or is of different type, it
243
* will return the default value.
244
*
245
* @param defaultValue the value to be returned if no value is found
246
* @return the entry's value or the given default value
247
*/
248
public float[] getFloatArray(float[] defaultValue) {
249
return NetworkTablesJNI.getFloatArray(m_handle, defaultValue);
250
}
251
252
/**
253
* Gets the entry's value as a boolean array. If the entry does not exist or is of different type,
254
* it will return the default value.
255
*
256
* @param defaultValue the value to be returned if no value is found
257
* @return the entry's value or the given default value
258
*/
259
public Float[] getFloatArray(Float[] defaultValue) {
260
return NetworkTableValue.fromNativeFloatArray(
261
getFloatArray(NetworkTableValue.toNativeFloatArray(defaultValue)));
262
}
263
264
/**
265
* Gets the entry's value as a double[]. If the entry does not exist or is of different type, it
266
* will return the default value.
267
*
268
* @param defaultValue the value to be returned if no value is found
269
* @return the entry's value or the given default value
270
*/
271
public double[] getDoubleArray(double[] defaultValue) {
272
return NetworkTablesJNI.getDoubleArray(m_handle, defaultValue);
273
}
274
275
/**
276
* Gets the entry's value as a boolean array. If the entry does not exist or is of different type,
277
* it will return the default value.
278
*
279
* @param defaultValue the value to be returned if no value is found
280
* @return the entry's value or the given default value
281
*/
282
public Double[] getDoubleArray(Double[] defaultValue) {
283
return NetworkTableValue.fromNativeDoubleArray(
284
getDoubleArray(NetworkTableValue.toNativeDoubleArray(defaultValue)));
285
}
286
287
/**
288
* Gets the entry's value as a String[]. If the entry does not exist or is of different type, it
289
* will return the default value.
290
*
291
* @param defaultValue the value to be returned if no value is found
292
* @return the entry's value or the given default value
293
*/
294
public String[] getStringArray(String[] defaultValue) {
295
return NetworkTablesJNI.getStringArray(m_handle, defaultValue);
296
}
297
298
/**
299
* Gets the entry's value as a double. If the entry does not exist or is of different type, it
300
* will return the default value.
301
*
302
* @param defaultValue the value to be returned if no value is found
303
* @return the entry's value or the given default value
304
*/
305
public Number getNumber(Number defaultValue) {
306
return getDouble(defaultValue.doubleValue());
307
}
308
309
/**
310
* Gets the entry's value as a double array. If the entry does not exist or is of different type,
311
* it will return the default value.
312
*
313
* @param defaultValue the value to be returned if no value is found
314
* @return the entry's value or the given default value
315
*/
316
public Number[] getNumberArray(Number[] defaultValue) {
317
return NetworkTableValue.fromNativeDoubleArray(
318
getDoubleArray(NetworkTableValue.toNativeDoubleArray(defaultValue)));
319
}
320
321
/**
322
* Get an array of all value changes since the last call to readQueue.
323
*
324
* <p>The "poll storage" subscribe option can be used to set the queue
325
* depth.
326
*
327
* @return Array of values; empty array if no new changes have been
328
*     published since the previous call.
329
*/
330
public NetworkTableValue[] readQueue() {
331
return NetworkTablesJNI.readQueueValue(m_handle);
332
}
333
334
/**
335
* Checks if a data value is of a type that can be placed in a NetworkTable entry.
336
*
337
* @param data the data to check
338
* @return true if the data can be placed in an entry, false if it cannot
339
*/
340
public static boolean isValidDataType(Object data) {
341
return data instanceof Number
342
|| data instanceof Boolean
343
|| data instanceof String
344
|| data instanceof long[]
345
|| data instanceof Long[]
346
|| data instanceof float[]
347
|| data instanceof Float[]
348
|| data instanceof double[]
349
|| data instanceof Double[]
350
|| data instanceof Number[]
351
|| data instanceof boolean[]
352
|| data instanceof Boolean[]
353
|| data instanceof String[]
354
|| data instanceof byte[]
355
|| data instanceof Byte[];
356
}
357
358
/**
359
* Sets the entry's value if it does not exist.
360
*
361
* @param defaultValue the default value to set
362
* @return False if the entry exists with a different type
363
* @throws IllegalArgumentException if the value is not a known type
364
*/
365
public boolean setDefaultValue(Object defaultValue) {
366
if (defaultValue instanceof NetworkTableValue) {
367
long time = ((NetworkTableValue) defaultValue).getTime();
368
Object otherValue = ((NetworkTableValue) defaultValue).getValue();
369
switch (((NetworkTableValue) defaultValue).getType()) {
370
case kBoolean:
371
return NetworkTablesJNI.setDefaultBoolean(m_handle, time, (Boolean) otherValue);
372
case kInteger:
373
return NetworkTablesJNI.setDefaultInteger(
374
m_handle, time, ((Number) otherValue).longValue());
375
case kFloat:
376
return NetworkTablesJNI.setDefaultFloat(
377
m_handle, time, ((Number) otherValue).floatValue());
378
case kDouble:
379
return NetworkTablesJNI.setDefaultDouble(
380
m_handle, time, ((Number) otherValue).doubleValue());
381
case kString:
382
return NetworkTablesJNI.setDefaultString(m_handle, time, (String) otherValue);
383
case kRaw:
384
return NetworkTablesJNI.setDefaultRaw(m_handle, time, (byte[]) otherValue);
385
case kBooleanArray:
386
return NetworkTablesJNI.setDefaultBooleanArray(m_handle, time, (boolean[]) otherValue);
387
case kIntegerArray:
388
return NetworkTablesJNI.setDefaultIntegerArray(m_handle, time, (long[]) otherValue);
389
case kFloatArray:
390
return NetworkTablesJNI.setDefaultFloatArray(m_handle, time, (float[]) otherValue);
391
case kDoubleArray:
392
return NetworkTablesJNI.setDefaultDoubleArray(m_handle, time, (double[]) otherValue);
393
case kStringArray:
394
return NetworkTablesJNI.setDefaultStringArray(m_handle, time, (String[]) otherValue);
395
default:
396
return true;
397
}
398
} else if (defaultValue instanceof Boolean) {
399
return setDefaultBoolean((Boolean) defaultValue);
400
} else if (defaultValue instanceof Integer) {
401
return setDefaultInteger((Integer) defaultValue);
402
} else if (defaultValue instanceof Float) {
403
return setDefaultFloat((Float) defaultValue);
404
} else if (defaultValue instanceof Number) {
405
return setDefaultNumber((Number) defaultValue);
406
} else if (defaultValue instanceof String) {
407
return setDefaultString((String) defaultValue);
408
} else if (defaultValue instanceof byte[]) {
409
return setDefaultRaw((byte[]) defaultValue);
410
} else if (defaultValue instanceof boolean[]) {
411
return setDefaultBooleanArray((boolean[]) defaultValue);
412
} else if (defaultValue instanceof long[]) {
413
return setDefaultIntegerArray((long[]) defaultValue);
414
} else if (defaultValue instanceof float[]) {
415
return setDefaultFloatArray((float[]) defaultValue);
416
} else if (defaultValue instanceof double[]) {
417
return setDefaultDoubleArray((double[]) defaultValue);
418
} else if (defaultValue instanceof Boolean[]) {
419
return setDefaultBooleanArray((Boolean[]) defaultValue);
420
} else if (defaultValue instanceof Long[]) {
421
return setDefaultIntegerArray((Long[]) defaultValue);
422
} else if (defaultValue instanceof Float[]) {
423
return setDefaultFloatArray((Float[]) defaultValue);
424
} else if (defaultValue instanceof Number[]) {
425
return setDefaultNumberArray((Number[]) defaultValue);
426
} else if (defaultValue instanceof String[]) {
427
return setDefaultStringArray((String[]) defaultValue);
428
} else {
429
throw new IllegalArgumentException(
430
"Value of type " + defaultValue.getClass().getName() + " cannot be put into a table");
431
}
432
}
433
434
/**
435
* Sets the entry's value if it does not exist.
436
*
437
* @param defaultValue the default value to set
438
* @return False if the entry exists with a different type
439
*/
440
public boolean setDefaultBoolean(boolean defaultValue) {
441
return NetworkTablesJNI.setDefaultBoolean(m_handle, 0, defaultValue);
442
}
443
444
/**
445
* Sets the entry's value if it does not exist.
446
*
447
* @param defaultValue the default value to set
448
* @return False if the entry exists with a different type
449
*/
450
public boolean setDefaultInteger(long defaultValue) {
451
return NetworkTablesJNI.setDefaultInteger(m_handle, 0, defaultValue);
452
}
453
454
/**
455
* Sets the entry's value if it does not exist.
456
*
457
* @param defaultValue the default value to set
458
* @return False if the entry exists with a different type
459
*/
460
public boolean setDefaultFloat(float defaultValue) {
461
return NetworkTablesJNI.setDefaultFloat(m_handle, 0, defaultValue);
462
}
463
464
/**
465
* Sets the entry's value if it does not exist.
466
*
467
* @param defaultValue the default value to set
468
* @return False if the entry exists with a different type
469
*/
470
public boolean setDefaultDouble(double defaultValue) {
471
return NetworkTablesJNI.setDefaultDouble(m_handle, 0, defaultValue);
472
}
473
474
/**
475
* Sets the entry's value if it does not exist.
476
*
477
* @param defaultValue the default value to set
478
* @return False if the entry exists with a different type
479
*/
480
public boolean setDefaultString(String defaultValue) {
481
return NetworkTablesJNI.setDefaultString(m_handle, 0, defaultValue);
482
}
483
484
/**
485
* Sets the entry's value if it does not exist.
486
*
487
* @param defaultValue the default value to set
488
* @return False if the entry exists with a different type
489
*/
490
public boolean setDefaultRaw(byte[] defaultValue) {
491
return NetworkTablesJNI.setDefaultRaw(m_handle, 0, defaultValue);
492
}
493
494
/**
495
* Sets the entry's value if it does not exist.
496
*
497
* @param defaultValue the default value to set; will send from defaultValue.position() to
498
*                     defaultValue.capacity()
499
* @return False if the entry exists with a different type
500
*/
501
public boolean setDefaultRaw(ByteBuffer defaultValue) {
502
return NetworkTablesJNI.setDefaultRaw(m_handle, 0, defaultValue);
503
}
504
505
/**
506
* Sets the entry's value if it does not exist.
507
*
508
* @param defaultValue the default value to set
509
* @param start Start position of data (in buffer)
510
* @param len Length of data (must be less than or equal to value.length - start)
511
* @return False if the entry exists with a different type
512
*/
513
public boolean setDefaultRaw(byte[] defaultValue, int start, int len) {
514
return NetworkTablesJNI.setDefaultRaw(m_handle, 0, defaultValue, start, len);
515
}
516
517
/**
518
* Sets the entry's value if it does not exist.
519
*
520
* @param defaultValue the default value to set
521
* @param start Start position of data (in buffer)
522
* @param len Length of data (must be less than or equal to value.capacity() - start)
523
* @return False if the entry exists with a different type
524
*/
525
public boolean setDefaultRaw(ByteBuffer defaultValue, int start, int len) {
526
return NetworkTablesJNI.setDefaultRaw(m_handle, 0, defaultValue, start, len);
527
}
528
529
/**
530
* Sets the entry's value if it does not exist.
531
*
532
* @param defaultValue the default value to set
533
* @return False if the entry exists with a different type
534
*/
535
public boolean setDefaultBooleanArray(boolean[] defaultValue) {
536
return NetworkTablesJNI.setDefaultBooleanArray(m_handle, 0, defaultValue);
537
}
538
539
/**
540
* Sets the entry's value if it does not exist.
541
*
542
* @param defaultValue the default value to set
543
* @return False if the entry exists with a different type
544
*/
545
public boolean setDefaultBooleanArray(Boolean[] defaultValue) {
546
return setDefaultBooleanArray(NetworkTableValue.toNativeBooleanArray(defaultValue));
547
}
548
549
/**
550
* Sets the entry's value if it does not exist.
551
*
552
* @param defaultValue the default value to set
553
* @return False if the entry exists with a different type
554
*/
555
public boolean setDefaultIntegerArray(long[] defaultValue) {
556
return NetworkTablesJNI.setDefaultIntegerArray(m_handle, 0, defaultValue);
557
}
558
559
/**
560
* Sets the entry's value if it does not exist.
561
*
562
* @param defaultValue the default value to set
563
* @return False if the entry exists with a different type
564
*/
565
public boolean setDefaultIntegerArray(Long[] defaultValue) {
566
return setDefaultIntegerArray(NetworkTableValue.toNativeIntegerArray(defaultValue));
567
}
568
569
/**
570
* Sets the entry's value if it does not exist.
571
*
572
* @param defaultValue the default value to set
573
* @return False if the entry exists with a different type
574
*/
575
public boolean setDefaultFloatArray(float[] defaultValue) {
576
return NetworkTablesJNI.setDefaultFloatArray(m_handle, 0, defaultValue);
577
}
578
579
/**
580
* Sets the entry's value if it does not exist.
581
*
582
* @param defaultValue the default value to set
583
* @return False if the entry exists with a different type
584
*/
585
public boolean setDefaultFloatArray(Float[] defaultValue) {
586
return setDefaultFloatArray(NetworkTableValue.toNativeFloatArray(defaultValue));
587
}
588
589
/**
590
* Sets the entry's value if it does not exist.
591
*
592
* @param defaultValue the default value to set
593
* @return False if the entry exists with a different type
594
*/
595
public boolean setDefaultDoubleArray(double[] defaultValue) {
596
return NetworkTablesJNI.setDefaultDoubleArray(m_handle, 0, defaultValue);
597
}
598
599
/**
600
* Sets the entry's value if it does not exist.
601
*
602
* @param defaultValue the default value to set
603
* @return False if the entry exists with a different type
604
*/
605
public boolean setDefaultDoubleArray(Double[] defaultValue) {
606
return setDefaultDoubleArray(NetworkTableValue.toNativeDoubleArray(defaultValue));
607
}
608
609
/**
610
* Sets the entry's value if it does not exist.
611
*
612
* @param defaultValue the default value to set
613
* @return False if the entry exists with a different type
614
*/
615
public boolean setDefaultStringArray(String[] defaultValue) {
616
return NetworkTablesJNI.setDefaultStringArray(m_handle, 0, defaultValue);
617
}
618
619
/**
620
* Sets the entry's value if it does not exist.
621
*
622
* @param defaultValue the default value to set
623
* @return False if the entry exists with a different type
624
*/
625
public boolean setDefaultNumber(Number defaultValue) {
626
return setDefaultDouble(defaultValue.doubleValue());
627
}
628
629
/**
630
* Sets the entry's value if it does not exist.
631
*
632
* @param defaultValue the default value to set
633
* @return False if the entry exists with a different type
634
*/
635
public boolean setDefaultNumberArray(Number[] defaultValue) {
636
return setDefaultDoubleArray(NetworkTableValue.toNativeDoubleArray(defaultValue));
637
}
638
639
/**
640
* Sets the entry's value.
641
*
642
* @param value the value that will be assigned
643
* @return False if the table key already exists with a different type
644
* @throws IllegalArgumentException if the value is not a known type
645
*/
646
public boolean setValue(Object value) {
647
if (value instanceof NetworkTableValue) {
648
long time = ((NetworkTableValue) value).getTime();
649
Object otherValue = ((NetworkTableValue) value).getValue();
650
switch (((NetworkTableValue) value).getType()) {
651
case kBoolean:
652
return NetworkTablesJNI.setBoolean(m_handle, time, (Boolean) otherValue);
653
case kInteger:
654
return NetworkTablesJNI.setInteger(
655
m_handle, time, ((Number) otherValue).longValue());
656
case kFloat:
657
return NetworkTablesJNI.setFloat(
658
m_handle, time, ((Number) otherValue).floatValue());
659
case kDouble:
660
return NetworkTablesJNI.setDouble(
661
m_handle, time, ((Number) otherValue).doubleValue());
662
case kString:
663
return NetworkTablesJNI.setString(m_handle, time, (String) otherValue);
664
case kRaw:
665
return NetworkTablesJNI.setRaw(m_handle, time, (byte[]) otherValue);
666
case kBooleanArray:
667
return NetworkTablesJNI.setBooleanArray(m_handle, time, (boolean[]) otherValue);
668
case kIntegerArray:
669
return NetworkTablesJNI.setIntegerArray(m_handle, time, (long[]) otherValue);
670
case kFloatArray:
671
return NetworkTablesJNI.setFloatArray(m_handle, time, (float[]) otherValue);
672
case kDoubleArray:
673
return NetworkTablesJNI.setDoubleArray(m_handle, time, (double[]) otherValue);
674
case kStringArray:
675
return NetworkTablesJNI.setStringArray(m_handle, time, (String[]) otherValue);
676
default:
677
return true;
678
}
679
} else if (value instanceof Boolean) {
680
return setBoolean((Boolean) value);
681
} else if (value instanceof Long) {
682
return setInteger((Long) value);
683
} else if (value instanceof Float) {
684
return setFloat((Float) value);
685
} else if (value instanceof Number) {
686
return setNumber((Number) value);
687
} else if (value instanceof String) {
688
return setString((String) value);
689
} else if (value instanceof byte[]) {
690
return setRaw((byte[]) value);
691
} else if (value instanceof boolean[]) {
692
return setBooleanArray((boolean[]) value);
693
} else if (value instanceof long[]) {
694
return setIntegerArray((long[]) value);
695
} else if (value instanceof float[]) {
696
return setFloatArray((float[]) value);
697
} else if (value instanceof double[]) {
698
return setDoubleArray((double[]) value);
699
} else if (value instanceof Boolean[]) {
700
return setBooleanArray((Boolean[]) value);
701
} else if (value instanceof Long[]) {
702
return setIntegerArray((Long[]) value);
703
} else if (value instanceof Float[]) {
704
return setFloatArray((Float[]) value);
705
} else if (value instanceof Number[]) {
706
return setNumberArray((Number[]) value);
707
} else if (value instanceof String[]) {
708
return setStringArray((String[]) value);
709
} else {
710
throw new IllegalArgumentException(
711
"Value of type " + value.getClass().getName() + " cannot be put into a table");
712
}
713
}
714
715
/**
716
* Sets the entry's value.
717
*
718
* @param value the value to set
719
* @return False if the entry exists with a different type
720
*/
721
public boolean setBoolean(boolean value) {
722
return NetworkTablesJNI.setBoolean(m_handle, 0, value);
723
}
724
725
/**
726
* Sets the entry's value.
727
*
728
* @param value the value to set
729
* @return False if the entry exists with a different type
730
*/
731
public boolean setInteger(long value) {
732
return NetworkTablesJNI.setInteger(m_handle, 0, value);
733
}
734
735
/**
736
* Sets the entry's value.
737
*
738
* @param value the value to set
739
* @return False if the entry exists with a different type
740
*/
741
public boolean setFloat(float value) {
742
return NetworkTablesJNI.setFloat(m_handle, 0, value);
743
}
744
745
/**
746
* Sets the entry's value.
747
*
748
* @param value the value to set
749
* @return False if the entry exists with a different type
750
*/
751
public boolean setDouble(double value) {
752
return NetworkTablesJNI.setDouble(m_handle, 0, value);
753
}
754
755
/**
756
* Sets the entry's value.
757
*
758
* @param value the value to set
759
* @return False if the entry exists with a different type
760
*/
761
public boolean setString(String value) {
762
return NetworkTablesJNI.setString(m_handle, 0, value);
763
}
764
765
/**
766
* Sets the entry's value.
767
*
768
* @param value the value to set
769
* @return False if the entry exists with a different type
770
*/
771
public boolean setRaw(byte[] value) {
772
return NetworkTablesJNI.setRaw(m_handle, 0, value);
773
}
774
775
/**
776
* Sets the entry's value.
777
*
778
* @param value the value to set; will send from value.position() to value.capacity()
779
* @return False if the entry exists with a different type
780
*/
781
public boolean setRaw(ByteBuffer value) {
782
return NetworkTablesJNI.setRaw(m_handle, 0, value);
783
}
784
785
/**
786
* Sets the entry's value.
787
*
788
* @param value the value to set
789
* @param start Start position of data (in buffer)
790
* @param len Length of data (must be less than or equal to value.length - start)
791
* @return False if the entry exists with a different type
792
*/
793
public boolean setRaw(byte[] value, int start, int len) {
794
return NetworkTablesJNI.setRaw(m_handle, 0, value, start, len);
795
}
796
797
/**
798
* Sets the entry's value.
799
*
800
* @param value the value to set
801
* @param start Start position of data (in buffer)
802
* @param len Length of data (must be less than or equal to value.capacity() - start)
803
* @return False if the entry exists with a different type
804
*/
805
public boolean setRaw(ByteBuffer value, int start, int len) {
806
return NetworkTablesJNI.setRaw(m_handle, 0, value, start, len);
807
}
808
809
/**
810
* Sets the entry's value.
811
*
812
* @param value the value to set
813
* @return False if the entry exists with a different type
814
*/
815
public boolean setBooleanArray(boolean[] value) {
816
return NetworkTablesJNI.setBooleanArray(m_handle, 0, value);
817
}
818
819
/**
820
* Sets the entry's value.
821
*
822
* @param value the value to set
823
* @return False if the entry exists with a different type
824
*/
825
public boolean setBooleanArray(Boolean[] value) {
826
return setBooleanArray(NetworkTableValue.toNativeBooleanArray(value));
827
}
828
829
/**
830
* Sets the entry's value.
831
*
832
* @param value the value to set
833
* @return False if the entry exists with a different type
834
*/
835
public boolean setIntegerArray(long[] value) {
836
return NetworkTablesJNI.setIntegerArray(m_handle, 0, value);
837
}
838
839
/**
840
* Sets the entry's value.
841
*
842
* @param value the value to set
843
* @return False if the entry exists with a different type
844
*/
845
public boolean setIntegerArray(Long[] value) {
846
return setIntegerArray(NetworkTableValue.toNativeIntegerArray(value));
847
}
848
849
/**
850
* Sets the entry's value.
851
*
852
* @param value the value to set
853
* @return False if the entry exists with a different type
854
*/
855
public boolean setFloatArray(float[] value) {
856
return NetworkTablesJNI.setFloatArray(m_handle, 0, value);
857
}
858
859
/**
860
* Sets the entry's value.
861
*
862
* @param value the value to set
863
* @return False if the entry exists with a different type
864
*/
865
public boolean setFloatArray(Float[] value) {
866
return setFloatArray(NetworkTableValue.toNativeFloatArray(value));
867
}
868
869
/**
870
* Sets the entry's value.
871
*
872
* @param value the value to set
873
* @return False if the entry exists with a different type
874
*/
875
public boolean setDoubleArray(double[] value) {
876
return NetworkTablesJNI.setDoubleArray(m_handle, 0, value);
877
}
878
879
/**
880
* Sets the entry's value.
881
*
882
* @param value the value to set
883
* @return False if the entry exists with a different type
884
*/
885
public boolean setDoubleArray(Double[] value) {
886
return setDoubleArray(NetworkTableValue.toNativeDoubleArray(value));
887
}
888
889
/**
890
* Sets the entry's value.
891
*
892
* @param value the value to set
893
* @return False if the entry exists with a different type
894
*/
895
public boolean setStringArray(String[] value) {
896
return NetworkTablesJNI.setStringArray(m_handle, 0, value);
897
}
898
899
/**
900
* Sets the entry's value.
901
*
902
* @param value the value to set
903
* @return False if the entry exists with a different type
904
*/
905
public boolean setNumber(Number value) {
906
return setDouble(value.doubleValue());
907
}
908
909
/**
910
* Sets the entry's value.
911
*
912
* @param value the value to set
913
* @return False if the entry exists with a different type
914
*/
915
public boolean setNumberArray(Number[] value) {
916
return setDoubleArray(NetworkTableValue.toNativeDoubleArray(value));
917
}
918
919
/** Make value persistent through program restarts. */
920
public void setPersistent() {
921
NetworkTablesJNI.setTopicPersistent(m_topic.getHandle(), true);
922
}
923
924
/** Stop making value persistent through program restarts. */
925
public void clearPersistent() {
926
NetworkTablesJNI.setTopicPersistent(m_topic.getHandle(), false);
927
}
928
929
/**
930
* Returns whether the value is persistent through program restarts.
931
*
932
* @return True if the value is persistent.
933
*/
934
public boolean isPersistent() {
935
return NetworkTablesJNI.getTopicPersistent(m_topic.getHandle());
936
}
937
938
/** Stops publishing the entry if it's been published. */
939
public void unpublish() {
940
NetworkTablesJNI.unpublish(m_handle);
941
}
942
943
@Override
944
public boolean equals(Object other) {
945
return other == this || other instanceof NetworkTableEntry entry && m_handle == entry.m_handle;
946
}
947
948
@Override
949
public int hashCode() {
950
return m_handle;
951
}
952
953
private final Topic m_topic;
954
private final int m_handle;
955
}