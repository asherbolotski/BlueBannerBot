001
// Copyright (c) FIRST and other WPILib contributors.
002
// Open Source Software; you can modify and/or share it under the terms of
003
// the WPILib BSD license file in the root directory of this project.
004
005
package edu.wpi.first.wpilibj2.command;
006
007
import java.util.Set;
008
009
/**
010
* A class used internally to wrap commands while overriding a specific method; all other methods
011
* will call through to the wrapped command.
012
*
013
* <p>The rules for command compositions apply: command instances that are passed to it cannot be
014
* added to any other composition or scheduled individually, and the composition requires all
015
* subsystems its components require.
016
*/
017
public abstract class WrapperCommand extends Command {
018
/** Command being wrapped. */
019
protected final Command m_command;
020
021
/**
022
* Wrap a command.
023
*
024
* @param command the command being wrapped. Trying to directly schedule this command or add it to
025
*     a composition will throw an exception.
026
*/
027
@SuppressWarnings("this-escape")
028
protected WrapperCommand(Command command) {
029
CommandScheduler.getInstance().registerComposedCommands(command);
030
m_command = command;
031
// copy the wrapped command's name
032
setName(command.getName());
033
}
034
035
/** The initial subroutine of a command. Called once when the command is initially scheduled. */
036
@Override
037
public void initialize() {
038
m_command.initialize();
039
}
040
041
/** The main body of a command. Called repeatedly while the command is scheduled. */
042
@Override
043
public void execute() {
044
m_command.execute();
045
}
046
047
/**
048
* The action to take when the command ends. Called when either the command finishes normally, or
049
* when it interrupted/canceled.
050
*
051
* <p>Do not schedule commands here that share requirements with this command. Use {@link
052
* #andThen(Command...)} instead.
053
*
054
* @param interrupted whether the command was interrupted/canceled
055
*/
056
@Override
057
public void end(boolean interrupted) {
058
m_command.end(interrupted);
059
}
060
061
/**
062
* Whether the command has finished. Once a command finishes, the scheduler will call its end()
063
* method and un-schedule it.
064
*
065
* @return whether the command has finished.
066
*/
067
@Override
068
public boolean isFinished() {
069
return m_command.isFinished();
070
}
071
072
/**
073
* Specifies the set of subsystems used by this command. Two commands cannot use the same
074
* subsystem at the same time. If the command is scheduled as interruptible and another command is
075
* scheduled that shares a requirement, the command will be interrupted. Else, the command will
076
* not be scheduled. If no subsystems are required, return an empty set.
077
*
078
* <p>Note: it is recommended that user implementations contain the requirements as a field, and
079
* return that field here, rather than allocating a new set every time this is called.
080
*
081
* @return the set of subsystems that are required
082
*/
083
@Override
084
public Set<Subsystem> getRequirements() {
085
return m_command.getRequirements();
086
}
087
088
/**
089
* Whether the given command should run when the robot is disabled. Override to return true if the
090
* command should run when disabled.
091
*
092
* @return whether the command should run when the robot is disabled
093
*/
094
@Override
095
public boolean runsWhenDisabled() {
096
return m_command.runsWhenDisabled();
097
}
098
099
@Override
100
public InterruptionBehavior getInterruptionBehavior() {
101
return m_command.getInterruptionBehavior();
102
}
103
}