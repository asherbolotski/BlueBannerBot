001
// Copyright (c) FIRST and other WPILib contributors.
002
// Open Source Software; you can modify and/or share it under the terms of
003
// the WPILib BSD license file in the root directory of this project.
004
005
package edu.wpi.first.wpilibj.simulation;
006
007
import edu.wpi.first.hal.simulation.BufferCallback;
008
import edu.wpi.first.hal.simulation.ConstBufferCallback;
009
import edu.wpi.first.hal.simulation.I2CDataJNI;
010
import edu.wpi.first.hal.simulation.NotifyCallback;
011
012
/** A class to control a simulated I2C device. */
013
public class I2CSim {
014
private final int m_index;
015
016
/**
017
* Construct a new I2C simulation object.
018
*
019
* @param index the HAL index of the I2C object
020
*/
021
public I2CSim(int index) {
022
m_index = index;
023
}
024
025
/**
026
* Register a callback to be run when this I2C device is initialized.
027
*
028
* @param callback the callback
029
* @param initialNotify whether to run the callback with the initial state
030
* @return the {@link CallbackStore} object associated with this callback.
031
*/
032
public CallbackStore registerInitializedCallback(NotifyCallback callback, boolean initialNotify) {
033
int uid = I2CDataJNI.registerInitializedCallback(m_index, callback, initialNotify);
034
return new CallbackStore(m_index, uid, I2CDataJNI::cancelInitializedCallback);
035
}
036
037
/**
038
* Check whether this I2C device has been initialized.
039
*
040
* @return true if initialized
041
*/
042
public boolean getInitialized() {
043
return I2CDataJNI.getInitialized(m_index);
044
}
045
046
/**
047
* Define whether this I2C device has been initialized.
048
*
049
* @param initialized whether this device is initialized
050
*/
051
public void setInitialized(boolean initialized) {
052
I2CDataJNI.setInitialized(m_index, initialized);
053
}
054
055
/**
056
* Register a callback to be run whenever a `read` operation is done.
057
*
058
* @param callback the callback that is run on `read` operations
059
* @return the {@link CallbackStore} object associated with this callback.
060
*/
061
public CallbackStore registerReadCallback(BufferCallback callback) {
062
int uid = I2CDataJNI.registerReadCallback(m_index, callback);
063
return new CallbackStore(m_index, uid, I2CDataJNI::cancelReadCallback);
064
}
065
066
/**
067
* Register a callback to be run whenever a `write` operation is done.
068
*
069
* @param callback the callback that is run on `write` operations
070
* @return the {@link CallbackStore} object associated with this callback.
071
*/
072
public CallbackStore registerWriteCallback(ConstBufferCallback callback) {
073
int uid = I2CDataJNI.registerWriteCallback(m_index, callback);
074
return new CallbackStore(m_index, uid, I2CDataJNI::cancelWriteCallback);
075
}
076
077
/** Reset all I2C simulation data. */
078
public void resetData() {
079
I2CDataJNI.resetData(m_index);
080
}
081
}