001
// Copyright (c) FIRST and other WPILib contributors.
002
// Open Source Software; you can modify and/or share it under the terms of
003
// the WPILib BSD license file in the root directory of this project.
004
005
package edu.wpi.first.wpilibj.simulation;
006
007
import edu.wpi.first.hal.simulation.AccelerometerDataJNI;
008
import edu.wpi.first.hal.simulation.NotifyCallback;
009
import edu.wpi.first.wpilibj.BuiltInAccelerometer;
010
011
/** Class to control a simulated built-in accelerometer. */
012
public class BuiltInAccelerometerSim {
013
private final int m_index;
014
015
/** Constructs for the first built-in accelerometer. */
016
public BuiltInAccelerometerSim() {
017
m_index = 0;
018
}
019
020
/**
021
* Constructs from a BuiltInAccelerometer object.
022
*
023
* @param accel BuiltInAccelerometer to simulate
024
*/
025
@SuppressWarnings("PMD.UnusedFormalParameter")
026
public BuiltInAccelerometerSim(BuiltInAccelerometer accel) {
027
m_index = 0;
028
}
029
030
/**
031
* Register a callback to be run when this accelerometer activates.
032
*
033
* @param callback the callback
034
* @param initialNotify whether to run the callback with the initial state
035
* @return the {@link CallbackStore} object associated with this callback.
036
*/
037
public CallbackStore registerActiveCallback(NotifyCallback callback, boolean initialNotify) {
038
int uid = AccelerometerDataJNI.registerActiveCallback(m_index, callback, initialNotify);
039
return new CallbackStore(m_index, uid, AccelerometerDataJNI::cancelActiveCallback);
040
}
041
042
/**
043
* Check whether the accelerometer is active.
044
*
045
* @return true if active
046
*/
047
public boolean getActive() {
048
return AccelerometerDataJNI.getActive(m_index);
049
}
050
051
/**
052
* Define whether this accelerometer is active.
053
*
054
* @param active the new state
055
*/
056
public void setActive(boolean active) {
057
AccelerometerDataJNI.setActive(m_index, active);
058
}
059
060
/**
061
* Register a callback to be run whenever the range changes.
062
*
063
* @param callback the callback
064
* @param initialNotify whether to call the callback with the initial state
065
* @return the {@link CallbackStore} object associated with this callback.
066
*/
067
public CallbackStore registerRangeCallback(NotifyCallback callback, boolean initialNotify) {
068
int uid = AccelerometerDataJNI.registerRangeCallback(m_index, callback, initialNotify);
069
return new CallbackStore(m_index, uid, AccelerometerDataJNI::cancelRangeCallback);
070
}
071
072
/**
073
* Check the range of this accelerometer.
074
*
075
* @return the accelerometer range
076
*/
077
public int getRange() {
078
return AccelerometerDataJNI.getRange(m_index);
079
}
080
081
/**
082
* Change the range of this accelerometer.
083
*
084
* @param range the new accelerometer range
085
*/
086
public void setRange(int range) {
087
AccelerometerDataJNI.setRange(m_index, range);
088
}
089
090
/**
091
* Register a callback to be run whenever the X axis value changes.
092
*
093
* @param callback the callback
094
* @param initialNotify whether to call the callback with the initial state
095
* @return the {@link CallbackStore} object associated with this callback.
096
*/
097
public CallbackStore registerXCallback(NotifyCallback callback, boolean initialNotify) {
098
int uid = AccelerometerDataJNI.registerXCallback(m_index, callback, initialNotify);
099
return new CallbackStore(m_index, uid, AccelerometerDataJNI::cancelXCallback);
100
}
101
102
/**
103
* Measure the X axis value.
104
*
105
* @return the X axis measurement
106
*/
107
public double getX() {
108
return AccelerometerDataJNI.getX(m_index);
109
}
110
111
/**
112
* Change the X axis value of the accelerometer.
113
*
114
* @param x the new reading of the X axis
115
*/
116
public void setX(double x) {
117
AccelerometerDataJNI.setX(m_index, x);
118
}
119
120
/**
121
* Register a callback to be run whenever the Y axis value changes.
122
*
123
* @param callback the callback
124
* @param initialNotify whether to call the callback with the initial state
125
* @return the {@link CallbackStore} object associated with this callback.
126
*/
127
public CallbackStore registerYCallback(NotifyCallback callback, boolean initialNotify) {
128
int uid = AccelerometerDataJNI.registerYCallback(m_index, callback, initialNotify);
129
return new CallbackStore(m_index, uid, AccelerometerDataJNI::cancelYCallback);
130
}
131
132
/**
133
* Measure the Y axis value.
134
*
135
* @return the Y axis measurement
136
*/
137
public double getY() {
138
return AccelerometerDataJNI.getY(m_index);
139
}
140
141
/**
142
* Change the Y axis value of the accelerometer.
143
*
144
* @param y the new reading of the Y axis
145
*/
146
public void setY(double y) {
147
AccelerometerDataJNI.setY(m_index, y);
148
}
149
150
/**
151
* Register a callback to be run whenever the Z axis value changes.
152
*
153
* @param callback the callback
154
* @param initialNotify whether to call the callback with the initial state
155
* @return the {@link CallbackStore} object associated with this callback.
156
*/
157
public CallbackStore registerZCallback(NotifyCallback callback, boolean initialNotify) {
158
int uid = AccelerometerDataJNI.registerZCallback(m_index, callback, initialNotify);
159
return new CallbackStore(m_index, uid, AccelerometerDataJNI::cancelZCallback);
160
}
161
162
/**
163
* Measure the Z axis value.
164
*
165
* @return the Z axis measurement
166
*/
167
public double getZ() {
168
return AccelerometerDataJNI.getZ(m_index);
169
}
170
171
/**
172
* Change the Z axis value of the accelerometer.
173
*
174
* @param z the new reading of the Z axis
175
*/
176
public void setZ(double z) {
177
AccelerometerDataJNI.setZ(m_index, z);
178
}
179
180
/** Reset all simulation data of this object. */
181
public void resetData() {
182
AccelerometerDataJNI.resetData(m_index);
183
}
184
}