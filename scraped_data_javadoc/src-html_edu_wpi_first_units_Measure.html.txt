001
// Copyright (c) FIRST and other WPILib contributors.
002
// Open Source Software; you can modify and/or share it under the terms of
003
// the WPILib BSD license file in the root directory of this project.
004
005
package edu.wpi.first.units;
006
007
import static edu.wpi.first.units.Units.Value;
008
009
import edu.wpi.first.units.measure.Acceleration;
010
import edu.wpi.first.units.measure.Angle;
011
import edu.wpi.first.units.measure.AngularAcceleration;
012
import edu.wpi.first.units.measure.AngularMomentum;
013
import edu.wpi.first.units.measure.AngularVelocity;
014
import edu.wpi.first.units.measure.Current;
015
import edu.wpi.first.units.measure.Dimensionless;
016
import edu.wpi.first.units.measure.Distance;
017
import edu.wpi.first.units.measure.Energy;
018
import edu.wpi.first.units.measure.Force;
019
import edu.wpi.first.units.measure.Frequency;
020
import edu.wpi.first.units.measure.LinearAcceleration;
021
import edu.wpi.first.units.measure.LinearMomentum;
022
import edu.wpi.first.units.measure.LinearVelocity;
023
import edu.wpi.first.units.measure.Mass;
024
import edu.wpi.first.units.measure.MomentOfInertia;
025
import edu.wpi.first.units.measure.Mult;
026
import edu.wpi.first.units.measure.Per;
027
import edu.wpi.first.units.measure.Power;
028
import edu.wpi.first.units.measure.Resistance;
029
import edu.wpi.first.units.measure.Temperature;
030
import edu.wpi.first.units.measure.Time;
031
import edu.wpi.first.units.measure.Torque;
032
import edu.wpi.first.units.measure.Velocity;
033
import edu.wpi.first.units.measure.Voltage;
034
035
/**
036
* A measure holds the magnitude and unit of some dimension, such as distance, time, or speed. Two
037
* measures with the same <i>unit</i> and <i>magnitude</i> are effectively equivalent objects.
038
*
039
* @param <U> the unit type of the measure
040
*/
041
public interface Measure<U extends Unit> extends Comparable<Measure<U>> {
042
/**
043
* The threshold for two measures to be considered equivalent if converted to the same unit. This
044
* is only needed due to floating-point error.
045
*/
046
double EQUIVALENCE_THRESHOLD = 1e-12;
047
048
/**
049
* Gets the unitless magnitude of this measure.
050
*
051
* @return the magnitude in terms of {@link #unit() the unit}.
052
*/
053
double magnitude();
054
055
/**
056
* Gets the magnitude of this measure in terms of the base unit. If the unit is the base unit for
057
* its system of measure, then the value will be equivalent to {@link #magnitude()}.
058
*
059
* @return the magnitude in terms of the base unit
060
*/
061
double baseUnitMagnitude();
062
063
/**
064
* Gets the units of this measure.
065
*
066
* @return the unit
067
*/
068
U unit();
069
070
/**
071
* Converts this measure to a measure with a different unit of the same type, eg minutes to
072
* seconds. Converting to the same unit is equivalent to calling {@link #magnitude()}.
073
*
074
* <pre>
075
*   Meters.of(12).in(Feet) // 39.3701
076
*   Seconds.of(15).in(Minutes) // 0.25
077
* </pre>
078
*
079
* @param unit the unit to convert this measure to
080
* @return the value of this measure in the given unit
081
*/
082
default double in(U unit) {
083
if (this.unit().equals(unit)) {
084
return magnitude();
085
} else {
086
return unit.fromBaseUnits(baseUnitMagnitude());
087
}
088
}
089
090
/**
091
* A convenience method to get the base unit of the measurement. Equivalent to {@code
092
* unit().getBaseUnit()}.
093
*
094
* @return the base unit of measure.
095
*/
096
@SuppressWarnings("unchecked")
097
default U baseUnit() {
098
return (U) unit().getBaseUnit();
099
}
100
101
/**
102
* Absolute value of measure.
103
*
104
* @param unit unit to use
105
* @return the absolute value of this measure in the given unit
106
*/
107
default double abs(U unit) {
108
return Math.abs(this.in(unit));
109
}
110
111
/**
112
* Take the sign of another measure.
113
*
114
* @param other measure from which to take sign
115
* @param unit unit to use
116
* @return the value of the measure in the given unit with the sign of the provided measure
117
*/
118
default double copySign(Measure<U> other, U unit) {
119
return Math.copySign(this.in(unit), other.in(unit));
120
}
121
122
/**
123
* Returns an immutable copy of this measure. The copy can be used freely and is guaranteed never
124
* to change.
125
*
126
* @return the copied measure
127
*/
128
Measure<U> copy();
129
130
/**
131
* Returns a mutable copy of this measure. It will be initialized to the current state of this
132
* measure, but can be changed over time without needing to allocate new measurement objects.
133
*
134
* @return the copied measure
135
*/
136
MutableMeasure<U, ?, ?> mutableCopy();
137
138
/**
139
* Returns a measure equivalent to this one equal to zero minus its current value. For non-linear
140
* unit types like temperature, the zero point is treated as the zero value of the base unit (eg
141
* Kelvin). In effect, this means code like {@code Celsius.of(10).unaryMinus()} returns a value
142
* equivalent to -10 Kelvin, and <i>not</i> -10° Celsius.
143
*
144
* @return a measure equal to zero minus this measure
145
*/
146
Measure<U> unaryMinus();
147
148
/**
149
* Returns a measure equivalent to this one equal to zero minus its current value. For non-linear
150
* unit types like temperature, the zero point is treated as the zero value of the base unit (eg
151
* Kelvin). In effect, this means code like {@code Celsius.of(10).negate()} returns a value
152
* equivalent to -10 Kelvin, and <i>not</i> -10° Celsius.
153
*
154
* @return a measure equal to zero minus this measure
155
* @deprecated use unaryMinus() instead. This was renamed for consistency with other WPILib
156
*     classes like Rotation2d
157
*/
158
@Deprecated(since = "2025", forRemoval = true)
159
default Measure<U> negate() {
160
return unaryMinus();
161
}
162
163
/**
164
* Adds another measure of the same unit type to this one.
165
*
166
* @param other the measurement to add
167
* @return a measure of the sum of both measures
168
*/
169
Measure<U> plus(Measure<? extends U> other);
170
171
/**
172
* Subtracts another measure of the same unit type from this one.
173
*
174
* @param other the measurement to subtract
175
* @return a measure of the difference between the measures
176
*/
177
Measure<U> minus(Measure<? extends U> other);
178
179
/**
180
* Multiplies this measure by a scalar unitless multiplier.
181
*
182
* @param multiplier the scalar multiplication factor
183
* @return the scaled result
184
*/
185
Measure<U> times(double multiplier);
186
187
/**
188
* Multiplies this measure by a scalar dimensionless multiplier.
189
*
190
* @param multiplier the scalar multiplication factor
191
* @return the scaled result
192
*/
193
Measure<U> times(Dimensionless multiplier);
194
195
/**
196
* Generates a new measure that is equal to this measure multiplied by another. Some dimensional
197
* analysis is performed to reduce the units down somewhat; for example, multiplying a {@code
198
* Measure<Time>} by a {@code Measure<Velocity<Distance>>} will return just a {@code
199
* Measure<Distance>} instead of the naive {@code Measure<Mult<Time, Velocity<Distance>>}. This is
200
* not guaranteed to perform perfect dimensional analysis.
201
*
202
* @param multiplier the unit to multiply by
203
* @return the multiplicative unit
204
*/
205
default Measure<?> times(Measure<?> multiplier) {
206
final double baseUnitResult = baseUnitMagnitude() * multiplier.baseUnitMagnitude();
207
208
// First try to eliminate any common units
209
if (unit() instanceof PerUnit<?, ?> ratio
210
&& multiplier.baseUnit().equals(ratio.denominator().getBaseUnit())) {
211
// Per<N, D> * D -> yield N
212
// Case 1: denominator of the Per cancels out, return with just the units of the numerator
213
return ratio.numerator().ofBaseUnits(baseUnitResult);
214
} else if (multiplier.baseUnit() instanceof PerUnit<?, ?> ratio
215
&& baseUnit().equals(ratio.denominator().getBaseUnit())) {
216
// D * Per<N, D) -> yield N
217
// Case 2: Same as Case 1, just flipped between this and the multiplier
218
return ratio.numerator().ofBaseUnits(baseUnitResult);
219
} else if (unit() instanceof PerUnit<?, ?> per
220
&& multiplier.unit() instanceof PerUnit<?, ?> otherPer
221
&& per.denominator().getBaseUnit().equals(otherPer.numerator().getBaseUnit())
222
&& per.numerator().getBaseUnit().equals(otherPer.denominator().getBaseUnit())) {
223
// multiplying eg meters per second * milliseconds per foot
224
// return a scalar
225
return Value.of(baseUnitResult);
226
}
227
228
// No common units to eliminate, is one of them dimensionless?
229
// Note that this must come *after* the multiplier cases, otherwise
230
// Per<U, Dimensionless> * Dimensionless will not return a U
231
if (multiplier.unit() instanceof DimensionlessUnit) {
232
// scalar multiplication of this
233
return times(multiplier.baseUnitMagnitude());
234
} else if (unit() instanceof DimensionlessUnit) {
235
// scalar multiplication of multiplier
236
return multiplier.times(baseUnitMagnitude());
237
}
238
239
if (multiplier instanceof Acceleration<?> acceleration) {
240
return times(acceleration);
241
} else if (multiplier instanceof Angle angle) {
242
return times(angle);
243
} else if (multiplier instanceof AngularAcceleration angularAcceleration) {
244
return times(angularAcceleration);
245
} else if (multiplier instanceof AngularMomentum angularMomentum) {
246
return times(angularMomentum);
247
} else if (multiplier instanceof AngularVelocity angularVelocity) {
248
return times(angularVelocity);
249
} else if (multiplier instanceof Current current) {
250
return times(current);
251
} else if (multiplier instanceof Dimensionless dimensionless) {
252
// n.b. this case should already be covered
253
return times(dimensionless);
254
} else if (multiplier instanceof Distance distance) {
255
return times(distance);
256
} else if (multiplier instanceof Energy energy) {
257
return times(energy);
258
} else if (multiplier instanceof Force force) {
259
return times(force);
260
} else if (multiplier instanceof Frequency frequency) {
261
return times(frequency);
262
} else if (multiplier instanceof LinearAcceleration linearAcceleration) {
263
return times(linearAcceleration);
264
} else if (multiplier instanceof LinearVelocity linearVelocity) {
265
return times(linearVelocity);
266
} else if (multiplier instanceof Mass mass) {
267
return times(mass);
268
} else if (multiplier instanceof MomentOfInertia momentOfInertia) {
269
return times(momentOfInertia);
270
} else if (multiplier instanceof Mult<?, ?> mult) {
271
return times(mult);
272
} else if (multiplier instanceof Per<?, ?> per) {
273
return times(per);
274
} else if (multiplier instanceof Power power) {
275
return times(power);
276
} else if (multiplier instanceof Temperature temperature) {
277
return times(temperature);
278
} else if (multiplier instanceof Time time) {
279
return times(time);
280
} else if (multiplier instanceof Torque torque) {
281
return times(torque);
282
} else if (multiplier instanceof Velocity<?> velocity) {
283
return times(velocity);
284
} else if (multiplier instanceof Voltage voltage) {
285
return times(voltage);
286
} else if (multiplier instanceof Resistance resistance) {
287
return times(resistance);
288
} else {
289
// Dimensional analysis fallthrough or a generic input measure type
290
// Do a basic unit multiplication
291
return MultUnit.combine(unit(), multiplier.unit()).ofBaseUnits(baseUnitResult);
292
}
293
}
294
295
/**
296
* Multiplies this measure by an acceleration and returns the resulting measure in the most
297
* appropriate unit.
298
*
299
* @param multiplier the measurement to multiply by.
300
* @return the multiplication result
301
*/
302
default Measure<?> times(Acceleration<?> multiplier) {
303
return MultUnit.combine(unit(), multiplier.unit())
304
.ofBaseUnits(baseUnitMagnitude() * multiplier.baseUnitMagnitude());
305
}
306
307
/**
308
* Multiplies this measure by an angle and returns the resulting measure in the most appropriate
309
* unit.
310
*
311
* @param multiplier the measurement to multiply by.
312
* @return the multiplication result
313
*/
314
default Measure<?> times(Angle multiplier) {
315
return MultUnit.combine(unit(), multiplier.unit())
316
.ofBaseUnits(baseUnitMagnitude() * multiplier.baseUnitMagnitude());
317
}
318
319
/**
320
* Multiplies this measure by an angular acceleration and returns the resulting measure in the
321
* most appropriate unit.
322
*
323
* @param multiplier the measurement to multiply by.
324
* @return the multiplication result
325
*/
326
default Measure<?> times(AngularAcceleration multiplier) {
327
return MultUnit.combine(unit(), multiplier.unit())
328
.ofBaseUnits(baseUnitMagnitude() * multiplier.baseUnitMagnitude());
329
}
330
331
/**
332
* Multiplies this measure by an angular momentum and returns the resulting measure in the most
333
* appropriate unit.
334
*
335
* @param multiplier the measurement to multiply by.
336
* @return the multiplication result
337
*/
338
default Measure<?> times(AngularMomentum multiplier) {
339
return MultUnit.combine(unit(), multiplier.unit())
340
.ofBaseUnits(baseUnitMagnitude() * multiplier.baseUnitMagnitude());
341
}
342
343
/**
344
* Multiplies this measure by an angular velocity and returns the resulting measure in the most
345
* appropriate unit.
346
*
347
* @param multiplier the measurement to multiply by.
348
* @return the multiplication result
349
*/
350
default Measure<?> times(AngularVelocity multiplier) {
351
return MultUnit.combine(unit(), multiplier.unit())
352
.ofBaseUnits(baseUnitMagnitude() * multiplier.baseUnitMagnitude());
353
}
354
355
/**
356
* Multiplies this measure by an electric current and returns the resulting measure in the most
357
* appropriate unit.
358
*
359
* @param multiplier the measurement to multiply by.
360
* @return the multiplication result
361
*/
362
default Measure<?> times(Current multiplier) {
363
return MultUnit.combine(unit(), multiplier.unit())
364
.ofBaseUnits(baseUnitMagnitude() * multiplier.baseUnitMagnitude());
365
}
366
367
/**
368
* Multiplies this measure by a distance and returns the resulting measure in the most appropriate
369
* unit.
370
*
371
* @param multiplier the measurement to multiply by.
372
* @return the multiplication result
373
*/
374
default Measure<?> times(Distance multiplier) {
375
return MultUnit.combine(unit(), multiplier.unit())
376
.ofBaseUnits(baseUnitMagnitude() * multiplier.baseUnitMagnitude());
377
}
378
379
/**
380
* Multiplies this measure by an energy and returns the resulting measure in the most appropriate
381
* unit.
382
*
383
* @param multiplier the measurement to multiply by.
384
* @return the multiplication result
385
*/
386
default Measure<?> times(Energy multiplier) {
387
return MultUnit.combine(unit(), multiplier.unit())
388
.ofBaseUnits(baseUnitMagnitude() * multiplier.baseUnitMagnitude());
389
}
390
391
/**
392
* Multiplies this measure by a force and returns the resulting measure in the most appropriate
393
* unit.
394
*
395
* @param multiplier the measurement to multiply by.
396
* @return the multiplication result
397
*/
398
default Measure<?> times(Force multiplier) {
399
return MultUnit.combine(unit(), multiplier.unit())
400
.ofBaseUnits(baseUnitMagnitude() * multiplier.baseUnitMagnitude());
401
}
402
403
/**
404
* Multiplies this measure by a frequency and returns the resulting measure in the most
405
* appropriate unit. This often - but not always - means implementations return a variation of a
406
* {@link Per} measure.
407
*
408
* @param multiplier the measurement to multiply by.
409
* @return the multiplication result
410
*/
411
default Measure<?> times(Frequency multiplier) {
412
return MultUnit.combine(unit(), multiplier.unit())
413
.ofBaseUnits(baseUnitMagnitude() * multiplier.baseUnitMagnitude());
414
}
415
416
/**
417
* Multiplies this measure by a linear acceleration and returns the resulting measure in the most
418
* appropriate unit.
419
*
420
* @param multiplier the measurement to multiply by.
421
* @return the multiplication result
422
*/
423
default Measure<?> times(LinearAcceleration multiplier) {
424
return MultUnit.combine(unit(), multiplier.unit())
425
.ofBaseUnits(baseUnitMagnitude() * multiplier.baseUnitMagnitude());
426
}
427
428
/**
429
* Multiplies this measure by a linear momentum and returns the resulting measure in the most
430
* appropriate unit.
431
*
432
* @param multiplier the measurement to multiply by.
433
* @return the multiplication result
434
*/
435
default Measure<?> times(LinearMomentum multiplier) {
436
return MultUnit.combine(unit(), multiplier.unit())
437
.ofBaseUnits(baseUnitMagnitude() * multiplier.baseUnitMagnitude());
438
}
439
440
/**
441
* Multiplies this measure by a linear velocity and returns the resulting measure in the most
442
* appropriate unit.
443
*
444
* @param multiplier the measurement to multiply by.
445
* @return the multiplication result
446
*/
447
default Measure<?> times(LinearVelocity multiplier) {
448
return MultUnit.combine(unit(), multiplier.unit())
449
.ofBaseUnits(baseUnitMagnitude() * multiplier.baseUnitMagnitude());
450
}
451
452
/**
453
* Multiplies this measure by a mass and returns the resulting measure in the most appropriate
454
* unit.
455
*
456
* @param multiplier the measurement to multiply by.
457
* @return the multiplication result
458
*/
459
default Measure<?> times(Mass multiplier) {
460
return MultUnit.combine(unit(), multiplier.unit())
461
.ofBaseUnits(baseUnitMagnitude() * multiplier.baseUnitMagnitude());
462
}
463
464
/**
465
* Multiplies this measure by a moment of intertia and returns the resulting measure in the most
466
* appropriate unit.
467
*
468
* @param multiplier the measurement to multiply by.
469
* @return the multiplication result
470
*/
471
default Measure<?> times(MomentOfInertia multiplier) {
472
return MultUnit.combine(unit(), multiplier.unit())
473
.ofBaseUnits(baseUnitMagnitude() * multiplier.baseUnitMagnitude());
474
}
475
476
/**
477
* Multiplies this measure by a generic multiplied measure and returns the resulting measure in
478
* the most appropriate unit.
479
*
480
* @param multiplier the measurement to multiply by.
481
* @return the multiplication result
482
*/
483
default Measure<?> times(Mult<?, ?> multiplier) {
484
return MultUnit.combine(unit(), multiplier.unit())
485
.ofBaseUnits(baseUnitMagnitude() * multiplier.baseUnitMagnitude());
486
}
487
488
/**
489
* Multiplies this measure by a power and returns the resulting measure in the most appropriate
490
* unit.
491
*
492
* @param multiplier the measurement to multiply by.
493
* @return the multiplication result
494
*/
495
default Measure<?> times(Power multiplier) {
496
return MultUnit.combine(unit(), multiplier.unit())
497
.ofBaseUnits(baseUnitMagnitude() * multiplier.baseUnitMagnitude());
498
}
499
500
/**
501
* Multiplies this measure by a generic ratio measurement and returns the resulting measure in the
502
* most appropriate unit.
503
*
504
* @param multiplier the measurement to multiply by.
505
* @return the multiplication result
506
*/
507
default Measure<?> times(Per<?, ?> multiplier) {
508
return MultUnit.combine(unit(), multiplier.unit())
509
.ofBaseUnits(baseUnitMagnitude() * multiplier.baseUnitMagnitude());
510
}
511
512
/**
513
* Multiplies this measure by a temperature and returns the resulting measure in the most
514
* appropriate unit.
515
*
516
* @param multiplier the measurement to multiply by.
517
* @return the multiplication result
518
*/
519
default Measure<?> times(Temperature multiplier) {
520
return MultUnit.combine(unit(), multiplier.unit())
521
.ofBaseUnits(baseUnitMagnitude() * multiplier.baseUnitMagnitude());
522
}
523
524
/**
525
* Multiplies this measure by a time and returns the resulting measure in the most appropriate
526
* unit.
527
*
528
* @param multiplier the measurement to multiply by.
529
* @return the multiplication result
530
*/
531
default Measure<?> times(Time multiplier) {
532
return MultUnit.combine(unit(), multiplier.unit())
533
.ofBaseUnits(baseUnitMagnitude() * multiplier.baseUnitMagnitude());
534
}
535
536
/**
537
* Multiplies this measure by a torque and returns the resulting measure in the most appropriate
538
* unit.
539
*
540
* @param multiplier the measurement to multiply by.
541
* @return the multiplication result
542
*/
543
default Measure<?> times(Torque multiplier) {
544
return MultUnit.combine(unit(), multiplier.unit())
545
.ofBaseUnits(baseUnitMagnitude() * multiplier.baseUnitMagnitude());
546
}
547
548
/**
549
* Multiplies this measure by a generic velocity and returns the resulting measure in the most
550
* appropriate unit.
551
*
552
* @param multiplier the measurement to multiply by.
553
* @return the multiplication result
554
*/
555
default Measure<?> times(Velocity<?> multiplier) {
556
return MultUnit.combine(unit(), multiplier.unit())
557
.ofBaseUnits(baseUnitMagnitude() * multiplier.baseUnitMagnitude());
558
}
559
560
/**
561
* Multiplies this measure by a voltage and returns the resulting measure in the most appropriate
562
* unit.
563
*
564
* @param multiplier the measurement to multiply by.
565
* @return the multiplication result
566
*/
567
default Measure<?> times(Voltage multiplier) {
568
return MultUnit.combine(unit(), multiplier.unit())
569
.ofBaseUnits(baseUnitMagnitude() * multiplier.baseUnitMagnitude());
570
}
571
572
/**
573
* Multiplies this measure by a resistance and returns the resulting measure in the most
574
* appropriate unit.
575
*
576
* @param multiplier the measurement to multiply by.
577
* @return the multiplication result
578
*/
579
default Measure<?> times(Resistance multiplier) {
580
return MultUnit.combine(unit(), multiplier.unit())
581
.ofBaseUnits(baseUnitMagnitude() * multiplier.baseUnitMagnitude());
582
}
583
584
/**
585
* Multiplies this measure by a conversion factor, returning the converted measurement. Unlike
586
* {@link #times(Per)}, this allows for basic unit cancellation to return measurements of a known
587
* dimension.
588
*
589
* @param conversionFactor the conversion factor by which to multiply
590
* @param <Other> the unit type to convert to
591
* @param <M> the concrete return unit type. <strong>Note: the conversion factor's numerator unit
592
*     must return instances of this type from {@link Unit#ofBaseUnits(double)}}</strong>
593
* @return the converted result
594
*/
595
@SuppressWarnings("unchecked")
596
default <Other extends Unit, M extends Measure<Other>> M timesConversionFactor(
597
Measure<? extends PerUnit<Other, U>> conversionFactor) {
598
return (M)
599
conversionFactor
600
.unit()
601
.getBaseUnit()
602
.numerator()
603
.ofBaseUnits(baseUnitMagnitude() * conversionFactor.baseUnitMagnitude());
604
}
605
606
/**
607
* Multiplies this measure by another measurement of the inverse unit type (eg Time multiplied by
608
* Frequency) and returns the resulting dimensionless measure.
609
*
610
* @param multiplier the measurement to multiply by.
611
* @return the multiplication result
612
*/
613
default Dimensionless timesInverse(
614
Measure<? extends PerUnit<DimensionlessUnit, ? extends U>> multiplier) {
615
return Value.ofBaseUnits(baseUnitMagnitude() * multiplier.baseUnitMagnitude());
616
}
617
618
/**
619
* Multiplies this measure by another measurement of something over the unit type (eg Time
620
* multiplied by LinearVelocity) and returns the resulting measure of the ratio's dividend unit.
621
*
622
* @param ratio the measurement to multiply by.
623
* @param <Other> other unit that the results are in terms of
624
* @return the multiplication result
625
*/
626
default <Other extends Unit> Measure<Other> timesRatio(
627
Measure<? extends PerUnit<? extends Other, U>> ratio) {
628
return ImmutableMeasure.ofBaseUnits(
629
baseUnitMagnitude() * ratio.baseUnitMagnitude(), ratio.unit().numerator());
630
}
631
632
/**
633
* Divides this measure by a unitless scalar and returns the result.
634
*
635
* @param divisor the measurement to divide by.
636
* @return the division result
637
*/
638
Measure<U> div(double divisor);
639
640
/**
641
* Divides this measure by a dimensionless scalar and returns the result.
642
*
643
* @param divisor the measurement to divide by.
644
* @return the division result
645
*/
646
Measure<U> div(Dimensionless divisor);
647
648
/**
649
* Divides this measurement by another measure and performs some dimensional analysis to reduce
650
* the units.
651
*
652
* @param divisor the unit to divide by
653
* @return the resulting measure
654
*/
655
default Measure<?> div(Measure<?> divisor) {
656
final double baseUnitResult = baseUnitMagnitude() / divisor.baseUnitMagnitude();
657
658
if (unit().getBaseUnit().equals(divisor.unit().getBaseUnit())) {
659
// These are the same unit, return a dimensionless
660
return Value.ofBaseUnits(baseUnitResult);
661
}
662
663
if (divisor instanceof Dimensionless) {
664
// Dividing by a dimensionless, do a scalar division
665
return unit().ofBaseUnits(baseUnitResult);
666
}
667
668
if (unit() instanceof DimensionlessUnit) {
669
// Numerator is a dimensionless
670
if (divisor.unit() instanceof PerUnit<?, ?> ratio) {
671
// Dividing by a ratio, return its reciprocal scaled by this
672
return ratio.reciprocal().ofBaseUnits(baseUnitResult);
673
}
674
if (divisor.unit() instanceof PerUnit<?, ?> ratio) {
675
// Dividing by a Per<Time, U>, return its reciprocal velocity scaled by this
676
// Note: Per<Time, U>.reciprocal() is coded to return a Velocity<U>
677
return ratio.reciprocal().ofBaseUnits(baseUnitResult);
678
}
679
}
680
681
if (divisor.unit() instanceof PerUnit<?, ?> ratio
682
&& ratio.numerator().getBaseUnit().equals(baseUnit())) {
683
// Numerator of the ratio cancels out
684
// N / (N / D) -> N * D / N -> D
685
// Note: all Velocity and Acceleration units inherit from PerUnit
686
return ratio.denominator().ofBaseUnits(baseUnitResult);
687
}
688
689
if (divisor.unit() instanceof TimeUnit time) {
690
// Dividing by a time, return a Velocity
691
return VelocityUnit.combine(unit(), time).ofBaseUnits(baseUnitResult);
692
}
693
694
if (divisor instanceof Acceleration<?> acceleration) {
695
return div(acceleration);
696
} else if (divisor instanceof Angle angle) {
697
return div(angle);
698
} else if (divisor instanceof AngularAcceleration angularAcceleration) {
699
return div(angularAcceleration);
700
} else if (divisor instanceof AngularMomentum angularMomentum) {
701
return div(angularMomentum);
702
} else if (divisor instanceof AngularVelocity angularVelocity) {
703
return div(angularVelocity);
704
} else if (divisor instanceof Current current) {
705
return div(current);
706
} else if (divisor instanceof Dimensionless dimensionless) {
707
// n.b. this case should already be covered
708
return div(dimensionless);
709
} else if (divisor instanceof Distance distance) {
710
return div(distance);
711
} else if (divisor instanceof Energy energy) {
712
return div(energy);
713
} else if (divisor instanceof Force force) {
714
return div(force);
715
} else if (divisor instanceof Frequency frequency) {
716
return div(frequency);
717
} else if (divisor instanceof LinearAcceleration linearAcceleration) {
718
return div(linearAcceleration);
719
} else if (divisor instanceof LinearVelocity linearVelocity) {
720
return div(linearVelocity);
721
} else if (divisor instanceof Mass mass) {
722
return div(mass);
723
} else if (divisor instanceof MomentOfInertia momentOfInertia) {
724
return div(momentOfInertia);
725
} else if (divisor instanceof Mult<?, ?> mult) {
726
return div(mult);
727
} else if (divisor instanceof Per<?, ?> per) {
728
return div(per);
729
} else if (divisor instanceof Power power) {
730
return div(power);
731
} else if (divisor instanceof Temperature temperature) {
732
return div(temperature);
733
} else if (divisor instanceof Time time) {
734
return div(time);
735
} else if (divisor instanceof Torque torque) {
736
return div(torque);
737
} else if (divisor instanceof Velocity<?> velocity) {
738
return div(velocity);
739
} else if (divisor instanceof Voltage voltage) {
740
return div(voltage);
741
} else if (divisor instanceof Resistance resistance) {
742
return div(resistance);
743
} else {
744
// Dimensional analysis fallthrough or a generic input measure type
745
// Do a basic unit multiplication
746
return PerUnit.combine(unit(), divisor.unit()).ofBaseUnits(baseUnitResult);
747
}
748
}
749
750
/**
751
* Divides this measure by a generic acceleration and returns the result in the most appropriate
752
* unit.
753
*
754
* @param divisor the measurement to divide by.
755
* @return the division result
756
*/
757
default Measure<?> div(Acceleration<?> divisor) {
758
return PerUnit.combine(unit(), divisor.unit())
759
.ofBaseUnits(baseUnitMagnitude() / divisor.baseUnitMagnitude());
760
}
761
762
/**
763
* Divides this measure by an angle and returns the result in the most appropriate unit.
764
*
765
* @param divisor the measurement to divide by.
766
* @return the division result
767
*/
768
default Measure<?> div(Angle divisor) {
769
return PerUnit.combine(unit(), divisor.unit())
770
.ofBaseUnits(baseUnitMagnitude() / divisor.baseUnitMagnitude());
771
}
772
773
/**
774
* Divides this measure by an angular acceleration and returns the result in the most appropriate
775
* unit.
776
*
777
* @param divisor the measurement to divide by.
778
* @return the division result
779
*/
780
default Measure<?> div(AngularAcceleration divisor) {
781
return PerUnit.combine(unit(), divisor.unit())
782
.ofBaseUnits(baseUnitMagnitude() / divisor.baseUnitMagnitude());
783
}
784
785
/**
786
* Divides this measure by an angular momentum and returns the result in the most appropriate
787
* unit.
788
*
789
* @param divisor the measurement to divide by.
790
* @return the division result
791
*/
792
default Measure<?> div(AngularMomentum divisor) {
793
return PerUnit.combine(unit(), divisor.unit())
794
.ofBaseUnits(baseUnitMagnitude() / divisor.baseUnitMagnitude());
795
}
796
797
/**
798
* Divides this measure by an angular velocity and returns the result in the most appropriate
799
* unit.
800
*
801
* @param divisor the measurement to divide by.
802
* @return the division result
803
*/
804
default Measure<?> div(AngularVelocity divisor) {
805
return PerUnit.combine(unit(), divisor.unit())
806
.ofBaseUnits(baseUnitMagnitude() / divisor.baseUnitMagnitude());
807
}
808
809
/**
810
* Divides this measure by an electric current and returns the result in the most appropriate
811
* unit.
812
*
813
* @param divisor the measurement to divide by.
814
* @return the division result
815
*/
816
default Measure<?> div(Current divisor) {
817
return PerUnit.combine(unit(), divisor.unit())
818
.ofBaseUnits(baseUnitMagnitude() / divisor.baseUnitMagnitude());
819
}
820
821
/**
822
* Divides this measure by a distance and returns the result in the most appropriate unit.
823
*
824
* @param divisor the measurement to divide by.
825
* @return the division result
826
*/
827
default Measure<?> div(Distance divisor) {
828
return PerUnit.combine(unit(), divisor.unit())
829
.ofBaseUnits(baseUnitMagnitude() / divisor.baseUnitMagnitude());
830
}
831
832
/**
833
* Divides this measure by an energy and returns the result in the most appropriate unit.
834
*
835
* @param divisor the measurement to divide by.
836
* @return the division result
837
*/
838
default Measure<?> div(Energy divisor) {
839
return PerUnit.combine(unit(), divisor.unit())
840
.ofBaseUnits(baseUnitMagnitude() / divisor.baseUnitMagnitude());
841
}
842
843
/**
844
* Divides this measure by a force and returns the result in the most appropriate unit.
845
*
846
* @param divisor the measurement to divide by.
847
* @return the division result
848
*/
849
default Measure<?> div(Force divisor) {
850
return PerUnit.combine(unit(), divisor.unit())
851
.ofBaseUnits(baseUnitMagnitude() / divisor.baseUnitMagnitude());
852
}
853
854
/**
855
* Divides this measure by a frequency and returns the result in the most appropriate unit.
856
*
857
* @param divisor the measurement to divide by.
858
* @return the division result
859
*/
860
default Measure<?> div(Frequency divisor) {
861
return PerUnit.combine(unit(), divisor.unit())
862
.ofBaseUnits(baseUnitMagnitude() / divisor.baseUnitMagnitude());
863
}
864
865
/**
866
* Divides this measure by a linear acceleration and returns the result in the most appropriate
867
* unit.
868
*
869
* @param divisor the measurement to divide by.
870
* @return the division result
871
*/
872
default Measure<?> div(LinearAcceleration divisor) {
873
return PerUnit.combine(unit(), divisor.unit())
874
.ofBaseUnits(baseUnitMagnitude() / divisor.baseUnitMagnitude());
875
}
876
877
/**
878
* Divides this measure by a linear momentum and returns the result in the most appropriate unit.
879
*
880
* @param divisor the measurement to divide by.
881
* @return the division result
882
*/
883
default Measure<?> div(LinearMomentum divisor) {
884
return PerUnit.combine(unit(), divisor.unit())
885
.ofBaseUnits(baseUnitMagnitude() / divisor.baseUnitMagnitude());
886
}
887
888
/**
889
* Divides this measure by a linear velocity and returns the result in the most appropriate unit.
890
*
891
* @param divisor the measurement to divide by.
892
* @return the division result
893
*/
894
default Measure<?> div(LinearVelocity divisor) {
895
return PerUnit.combine(unit(), divisor.unit())
896
.ofBaseUnits(baseUnitMagnitude() / divisor.baseUnitMagnitude());
897
}
898
899
/**
900
* Divides this measure by a mass and returns the result in the most appropriate unit.
901
*
902
* @param divisor the measurement to divide by.
903
* @return the division result
904
*/
905
default Measure<?> div(Mass divisor) {
906
return PerUnit.combine(unit(), divisor.unit())
907
.ofBaseUnits(baseUnitMagnitude() / divisor.baseUnitMagnitude());
908
}
909
910
/**
911
* Divides this measure by a moment of inertia and returns the result in the most appropriate
912
* unit.
913
*
914
* @param divisor the measurement to divide by.
915
* @return the division result
916
*/
917
default Measure<?> div(MomentOfInertia divisor) {
918
return PerUnit.combine(unit(), divisor.unit())
919
.ofBaseUnits(baseUnitMagnitude() / divisor.baseUnitMagnitude());
920
}
921
922
/**
923
* Divides this measure by a generic multiplication and returns the result in the most appropriate
924
* unit.
925
*
926
* @param divisor the measurement to divide by.
927
* @return the division result
928
*/
929
default Measure<?> div(Mult<?, ?> divisor) {
930
return PerUnit.combine(unit(), divisor.unit())
931
.ofBaseUnits(baseUnitMagnitude() / divisor.baseUnitMagnitude());
932
}
933
934
/**
935
* Divides this measure by a power and returns the result in the most appropriate unit.
936
*
937
* @param divisor the measurement to divide by.
938
* @return the division result
939
*/
940
default Measure<?> div(Power divisor) {
941
return PerUnit.combine(unit(), divisor.unit())
942
.ofBaseUnits(baseUnitMagnitude() / divisor.baseUnitMagnitude());
943
}
944
945
/**
946
* Divides this measure by a generic ratio and returns the result in the most appropriate unit.
947
*
948
* @param divisor the measurement to divide by.
949
* @return the division result
950
*/
951
default Measure<?> div(Per<?, ?> divisor) {
952
return PerUnit.combine(unit(), divisor.unit())
953
.ofBaseUnits(baseUnitMagnitude() / divisor.baseUnitMagnitude());
954
}
955
956
/**
957
* Divides this measure by a temperature and returns the result in the most appropriate unit.
958
*
959
* @param divisor the measurement to divide by.
960
* @return the division result
961
*/
962
default Measure<?> div(Temperature divisor) {
963
return PerUnit.combine(unit(), divisor.unit())
964
.ofBaseUnits(baseUnitMagnitude() / divisor.baseUnitMagnitude());
965
}
966
967
/**
968
* Divides this measure by a time and returns the result in the most appropriate unit. This will
969
* often - but not always - result in a {@link Per} type like {@link LinearVelocity} or {@link
970
* Acceleration}.
971
*
972
* @param divisor the measurement to divide by.
973
* @return the division result
974
*/
975
default Measure<?> div(Time divisor) {
976
return VelocityUnit.combine(unit(), divisor.unit())
977
.ofBaseUnits(baseUnitMagnitude() / divisor.baseUnitMagnitude());
978
}
979
980
/**
981
* Divides this measure by a torque and returns the result in the most appropriate unit.
982
*
983
* @param divisor the measurement to divide by.
984
* @return the division result
985
*/
986
default Measure<?> div(Torque divisor) {
987
return PerUnit.combine(unit(), divisor.unit())
988
.ofBaseUnits(baseUnitMagnitude() / divisor.baseUnitMagnitude());
989
}
990
991
/**
992
* Divides this measure by a generic velocity and returns the result in the most appropriate unit.
993
*
994
* @param divisor the measurement to divide by.
995
* @return the division result
996
*/
997
default Measure<?> div(Velocity<?> divisor) {
998
return PerUnit.combine(unit(), divisor.unit())
999
.ofBaseUnits(baseUnitMagnitude() / divisor.baseUnitMagnitude());
1000
}
1001
1002
/**
1003
* Divides this measure by a voltage and returns the result in the most appropriate unit.
1004
*
1005
* @param divisor the measurement to divide by.
1006
* @return the division result
1007
*/
1008
default Measure<?> div(Voltage divisor) {
1009
return PerUnit.combine(unit(), divisor.unit())
1010
.ofBaseUnits(baseUnitMagnitude() / divisor.baseUnitMagnitude());
1011
}
1012
1013
/**
1014
* Divides this measure by a resistance and returns the result in the most appropriate unit.
1015
*
1016
* @param divisor the measurement to divide by.
1017
* @return the division result
1018
*/
1019
default Measure<?> div(Resistance divisor) {
1020
return PerUnit.combine(unit(), divisor.unit())
1021
.ofBaseUnits(baseUnitMagnitude() / divisor.baseUnitMagnitude());
1022
}
1023
1024
/**
1025
* Divides this measure by an acceleration unit and returns the result in the most appropriate
1026
* unit. This is equivalent to {@code div(divisorUnit.of(1))}.
1027
*
1028
* @param divisorUnit the unit to divide by.
1029
* @return the division result
1030
*/
1031
default Measure<?> per(AccelerationUnit<?> divisorUnit) {
1032
return div(divisorUnit.one());
1033
}
1034
1035
/**
1036
* Divides this measure by an angle unit and returns the result in the most appropriate unit. This
1037
* is equivalent to {@code div(divisorUnit.of(1))}.
1038
*
1039
* @param divisorUnit the unit to divide by.
1040
* @return the division result
1041
*/
1042
default Measure<?> per(AngleUnit divisorUnit) {
1043
return div(divisorUnit.one());
1044
}
1045
1046
/**
1047
* Divides this measure by an angular acceleration unit and returns the result in the most
1048
* appropriate unit. This is equivalent to {@code div(divisorUnit.of(1))}.
1049
*
1050
* @param divisorUnit the unit to divide by.
1051
* @return the division result
1052
*/
1053
default Measure<?> per(AngularAccelerationUnit divisorUnit) {
1054
return div(divisorUnit.one());
1055
}
1056
1057
/**
1058
* Divides this measure by an angular momentum unit and returns the result in the most appropriate
1059
* unit. This is equivalent to {@code div(divisorUnit.of(1))}.
1060
*
1061
* @param divisorUnit the unit to divide by.
1062
* @return the division result
1063
*/
1064
default Measure<?> per(AngularMomentumUnit divisorUnit) {
1065
return div(divisorUnit.one());
1066
}
1067
1068
/**
1069
* Divides this measure by an angular velocity unit and returns the result in the most appropriate
1070
* unit. This is equivalent to {@code div(divisorUnit.of(1))}.
1071
*
1072
* @param divisorUnit the unit to divide by.
1073
* @return the division result
1074
*/
1075
default Measure<?> per(AngularVelocityUnit divisorUnit) {
1076
return div(divisorUnit.one());
1077
}
1078
1079
/**
1080
* Divides this measure by a unit of electric current and returns the result in the most
1081
* appropriate unit. This is equivalent to {@code div(divisorUnit.of(1))}.
1082
*
1083
* @param divisorUnit the unit to divide by.
1084
* @return the division result
1085
*/
1086
default Measure<?> per(CurrentUnit divisorUnit) {
1087
return div(divisorUnit.one());
1088
}
1089
1090
/**
1091
* Divides this measure by a distance unit and returns the result in the most appropriate unit.
1092
* This is equivalent to {@code div(divisorUnit.of(1))}.
1093
*
1094
* @param divisorUnit the unit to divide by.
1095
* @return the division result
1096
*/
1097
default Measure<?> per(DistanceUnit divisorUnit) {
1098
return div(divisorUnit.one());
1099
}
1100
1101
/**
1102
* Divides this measure by an energy unit and returns the result in the most appropriate unit.
1103
* This is equivalent to {@code div(divisorUnit.of(1))}.
1104
*
1105
* @param divisorUnit the unit to divide by.
1106
* @return the division result
1107
*/
1108
default Measure<?> per(EnergyUnit divisorUnit) {
1109
return div(divisorUnit.one());
1110
}
1111
1112
/**
1113
* Divides this measure by a force unit and returns the result in the most appropriate unit. This
1114
* is equivalent to {@code div(divisorUnit.of(1))}.
1115
*
1116
* @param divisorUnit the unit to divide by.
1117
* @return the division result
1118
*/
1119
default Measure<?> per(ForceUnit divisorUnit) {
1120
return div(divisorUnit.one());
1121
}
1122
1123
/**
1124
* Divides this measure by a frequency unit and returns the result in the most appropriate unit.
1125
* This is equivalent to {@code div(divisorUnit.of(1))}.
1126
*
1127
* @param divisorUnit the unit to divide by.
1128
* @return the division result
1129
*/
1130
default Measure<?> per(FrequencyUnit divisorUnit) {
1131
return div(divisorUnit.one());
1132
}
1133
1134
/**
1135
* Divides this measure by a linear acceleration unit and returns the result in the most
1136
* appropriate unit. This is equivalent to {@code div(divisorUnit.of(1))}.
1137
*
1138
* @param divisorUnit the unit to divide by.
1139
* @return the division result
1140
*/
1141
default Measure<?> per(LinearAccelerationUnit divisorUnit) {
1142
return div(divisorUnit.one());
1143
}
1144
1145
/**
1146
* Divides this measure by a linear momentum unit and returns the result in the most appropriate
1147
* unit. This is equivalent to {@code div(divisorUnit.of(1))}.
1148
*
1149
* @param divisorUnit the unit to divide by.
1150
* @return the division result
1151
*/
1152
default Measure<?> per(LinearMomentumUnit divisorUnit) {
1153
return div(divisorUnit.one());
1154
}
1155
1156
/**
1157
* Divides this measure by a linear velocity unit and returns the result in the most appropriate
1158
* unit. This is equivalent to {@code div(divisorUnit.of(1))}.
1159
*
1160
* @param divisorUnit the unit to divide by.
1161
* @return the division result
1162
*/
1163
default Measure<?> per(LinearVelocityUnit divisorUnit) {
1164
return div(divisorUnit.one());
1165
}
1166
1167
/**
1168
* Divides this measure by a mass unit and returns the result in the most appropriate unit. This
1169
* is equivalent to {@code div(divisorUnit.of(1))}.
1170
*
1171
* @param divisorUnit the unit to divide by.
1172
* @return the division result
1173
*/
1174
default Measure<?> per(MassUnit divisorUnit) {
1175
return div(divisorUnit.one());
1176
}
1177
1178
/**
1179
* Divides this measure by a moment of inertia unit and returns the result in the most appropriate
1180
* unit. This is equivalent to {@code div(divisorUnit.of(1))}.
1181
*
1182
* @param divisorUnit the unit to divide by.
1183
* @return the division result
1184
*/
1185
default Measure<?> per(MomentOfInertiaUnit divisorUnit) {
1186
return div(divisorUnit.one());
1187
}
1188
1189
/**
1190
* Divides this measure by a generic compound unit and returns the result in the most appropriate
1191
* unit. This is equivalent to {@code div(divisorUnit.of(1))}.
1192
*
1193
* @param divisorUnit the unit to divide by.
1194
* @return the division result
1195
*/
1196
default Measure<?> per(MultUnit<?, ?> divisorUnit) {
1197
return div(divisorUnit.one());
1198
}
1199
1200
/**
1201
* Divides this measure by a power unit and returns the result in the most appropriate unit. This
1202
* is equivalent to {@code div(divisorUnit.of(1))}.
1203
*
1204
* @param divisorUnit the unit to divide by.
1205
* @return the division result
1206
*/
1207
default Measure<?> per(PowerUnit divisorUnit) {
1208
return div(divisorUnit.one());
1209
}
1210
1211
/**
1212
* Divides this measure by a generic ratio unit and returns the result in the most appropriate
1213
* unit. This is equivalent to {@code div(divisorUnit.of(1))}.
1214
*
1215
* @param divisorUnit the unit to divide by.
1216
* @return the division result
1217
*/
1218
default Measure<?> per(PerUnit<?, ?> divisorUnit) {
1219
return div(divisorUnit.one());
1220
}
1221
1222
/**
1223
* Divides this measure by a temperature unit and returns the result in the most appropriate unit.
1224
* This is equivalent to {@code div(divisorUnit.of(1))}.
1225
*
1226
* @param divisorUnit the unit to divide by.
1227
* @return the division result
1228
*/
1229
default Measure<?> per(TemperatureUnit divisorUnit) {
1230
return div(divisorUnit.one());
1231
}
1232
1233
/**
1234
* Divides this measure by a time period and returns the result in the most appropriate unit. This
1235
* is equivalent to {@code div(period.of(1))}.
1236
*
1237
* @param period the time period measurement to divide by.
1238
* @return the division result
1239
*/
1240
default Measure<?> per(TimeUnit period) {
1241
return div(period.of(1));
1242
}
1243
1244
/**
1245
* Divides this measure by a torque unit and returns the result in the most appropriate unit. This
1246
* is equivalent to {@code div(divisorUnit.of(1))}.
1247
*
1248
* @param divisorUnit the unit to divide by.
1249
* @return the division result
1250
*/
1251
default Measure<?> per(TorqueUnit divisorUnit) {
1252
return div(divisorUnit.one());
1253
}
1254
1255
/**
1256
* Divides this measure by a velocity unit and returns the result in the most appropriate unit.
1257
* This is equivalent to {@code div(divisorUnit.of(1))}.
1258
*
1259
* @param divisorUnit the unit to divide by.
1260
* @return the division result
1261
*/
1262
default Measure<?> per(VelocityUnit<?> divisorUnit) {
1263
return div(divisorUnit.one());
1264
}
1265
1266
/**
1267
* Divides this measure by a voltage unit and returns the result in the most appropriate unit.
1268
* This is equivalent to {@code div(divisorUnit.of(1))}.
1269
*
1270
* @param divisorUnit the unit to divide by.
1271
* @return the division result
1272
*/
1273
default Measure<?> per(VoltageUnit divisorUnit) {
1274
return div(divisorUnit.one());
1275
}
1276
1277
/**
1278
* Divides this measure by a resistance unit and returns the result in the most appropriate unit.
1279
* This is equivalent to {@code div(divisorUnit.of(1))}.
1280
*
1281
* @param divisorUnit the unit to divide by.
1282
* @return the division result
1283
*/
1284
default Measure<?> per(ResistanceUnit divisorUnit) {
1285
return div(divisorUnit.one());
1286
}
1287
1288
/**
1289
* Divides this measure by a unitless scalar and returns the result.
1290
*
1291
* @param divisor the measurement to divide by.
1292
* @return the division result
1293
* @deprecated use div instead. This was renamed for consistency with other languages like Kotlin
1294
*/
1295
@Deprecated(since = "2025", forRemoval = true)
1296
default Measure<U> divide(double divisor) {
1297
return div(divisor);
1298
}
1299
1300
/**
1301
* Divides this measure by a dimensionless scalar and returns the result.
1302
*
1303
* @param divisor the measurement to divide by.
1304
* @return the division result
1305
* @deprecated use div instead. This was renamed for consistency with other languages like Kotlin
1306
*/
1307
@Deprecated(since = "2025", forRemoval = true)
1308
default Measure<U> divide(Dimensionless divisor) {
1309
return div(divisor);
1310
}
1311
1312
/**
1313
* Divides this measurement by another measure and performs some dimensional analysis to reduce
1314
* the units.
1315
*
1316
* @param divisor the unit to divide by
1317
* @return the resulting measure
1318
* @deprecated use div instead. This was renamed for consistency with other languages like Kotlin
1319
*/
1320
@Deprecated(since = "2025", forRemoval = true)
1321
default Measure<?> divide(Measure<?> divisor) {
1322
return div(divisor);
1323
}
1324
1325
/**
1326
* Divides this measure by a generic acceleration and returns the result in the most appropriate
1327
* unit.
1328
*
1329
* @param divisor the measurement to divide by.
1330
* @return the division result
1331
* @deprecated use div instead. This was renamed for consistency with other languages like Kotlin
1332
*/
1333
@Deprecated(since = "2025", forRemoval = true)
1334
default Measure<?> divide(Acceleration<?> divisor) {
1335
return div(divisor);
1336
}
1337
1338
/**
1339
* Divides this measure by an angle and returns the result in the most appropriate unit.
1340
*
1341
* @param divisor the measurement to divide by.
1342
* @return the division result
1343
* @deprecated use div instead. This was renamed for consistency with other languages like Kotlin
1344
*/
1345
@Deprecated(since = "2025", forRemoval = true)
1346
default Measure<?> divide(Angle divisor) {
1347
return div(divisor);
1348
}
1349
1350
/**
1351
* Divides this measure by an angular acceleration and returns the result in the most appropriate
1352
* unit.
1353
*
1354
* @param divisor the measurement to divide by.
1355
* @return the division result
1356
* @deprecated use div instead. This was renamed for consistency with other languages like Kotlin
1357
*/
1358
@Deprecated(since = "2025", forRemoval = true)
1359
default Measure<?> divide(AngularAcceleration divisor) {
1360
return div(divisor);
1361
}
1362
1363
/**
1364
* Divides this measure by an angular momentum and returns the result in the most appropriate
1365
* unit.
1366
*
1367
* @param divisor the measurement to divide by.
1368
* @return the division result
1369
* @deprecated use div instead. This was renamed for consistency with other languages like Kotlin
1370
*/
1371
@Deprecated(since = "2025", forRemoval = true)
1372
default Measure<?> divide(AngularMomentum divisor) {
1373
return div(divisor);
1374
}
1375
1376
/**
1377
* Divides this measure by an angular velocity and returns the result in the most appropriate
1378
* unit.
1379
*
1380
* @param divisor the measurement to divide by.
1381
* @return the division result
1382
* @deprecated use div instead. This was renamed for consistency with other languages like Kotlin
1383
*/
1384
@Deprecated(since = "2025", forRemoval = true)
1385
default Measure<?> divide(AngularVelocity divisor) {
1386
return div(divisor);
1387
}
1388
1389
/**
1390
* Divides this measure by an electric current and returns the result in the most appropriate
1391
* unit.
1392
*
1393
* @param divisor the measurement to divide by.
1394
* @return the division result
1395
* @deprecated use div instead. This was renamed for consistency with other languages like Kotlin
1396
*/
1397
@Deprecated(since = "2025", forRemoval = true)
1398
default Measure<?> divide(Current divisor) {
1399
return div(divisor);
1400
}
1401
1402
/**
1403
* Divides this measure by a distance and returns the result in the most appropriate unit.
1404
*
1405
* @param divisor the measurement to divide by.
1406
* @return the division result
1407
* @deprecated use div instead. This was renamed for consistency with other languages like Kotlin
1408
*/
1409
@Deprecated(since = "2025", forRemoval = true)
1410
default Measure<?> divide(Distance divisor) {
1411
return div(divisor);
1412
}
1413
1414
/**
1415
* Divides this measure by an energy and returns the result in the most appropriate unit.
1416
*
1417
* @param divisor the measurement to divide by.
1418
* @return the division result
1419
* @deprecated use div instead. This was renamed for consistency with other languages like Kotlin
1420
*/
1421
@Deprecated(since = "2025", forRemoval = true)
1422
default Measure<?> divide(Energy divisor) {
1423
return div(divisor);
1424
}
1425
1426
/**
1427
* Divides this measure by a force and returns the result in the most appropriate unit.
1428
*
1429
* @param divisor the measurement to divide by.
1430
* @return the division result
1431
* @deprecated use div instead. This was renamed for consistency with other languages like Kotlin
1432
*/
1433
@Deprecated(since = "2025", forRemoval = true)
1434
default Measure<?> divide(Force divisor) {
1435
return div(divisor);
1436
}
1437
1438
/**
1439
* Divides this measure by a frequency and returns the result in the most appropriate unit.
1440
*
1441
* @param divisor the measurement to divide by.
1442
* @return the division result
1443
* @deprecated use div instead. This was renamed for consistency with other languages like Kotlin
1444
*/
1445
@Deprecated(since = "2025", forRemoval = true)
1446
default Measure<?> divide(Frequency divisor) {
1447
return div(divisor);
1448
}
1449
1450
/**
1451
* Divides this measure by a linear acceleration and returns the result in the most appropriate
1452
* unit.
1453
*
1454
* @param divisor the measurement to divide by.
1455
* @return the division result
1456
* @deprecated use div instead. This was renamed for consistency with other languages like Kotlin
1457
*/
1458
@Deprecated(since = "2025", forRemoval = true)
1459
default Measure<?> divide(LinearAcceleration divisor) {
1460
return div(divisor);
1461
}
1462
1463
/**
1464
* Divides this measure by a linear momentum and returns the result in the most appropriate unit.
1465
*
1466
* @param divisor the measurement to divide by.
1467
* @return the division result
1468
* @deprecated use div instead. This was renamed for consistency with other languages like Kotlin
1469
*/
1470
@Deprecated(since = "2025", forRemoval = true)
1471
default Measure<?> divide(LinearMomentum divisor) {
1472
return div(divisor);
1473
}
1474
1475
/**
1476
* Divides this measure by a linear velocity and returns the result in the most appropriate unit.
1477
*
1478
* @param divisor the measurement to divide by.
1479
* @return the division result
1480
* @deprecated use div instead. This was renamed for consistency with other languages like Kotlin
1481
*/
1482
@Deprecated(since = "2025", forRemoval = true)
1483
default Measure<?> divide(LinearVelocity divisor) {
1484
return div(divisor);
1485
}
1486
1487
/**
1488
* Divides this measure by a mass and returns the result in the most appropriate unit.
1489
*
1490
* @param divisor the measurement to divide by.
1491
* @return the division result
1492
* @deprecated use div instead. This was renamed for consistency with other languages like Kotlin
1493
*/
1494
@Deprecated(since = "2025", forRemoval = true)
1495
default Measure<?> divide(Mass divisor) {
1496
return div(divisor);
1497
}
1498
1499
/**
1500
* Divides this measure by a moment of inertia and returns the result in the most appropriate
1501
* unit.
1502
*
1503
* @param divisor the measurement to divide by.
1504
* @return the division result
1505
* @deprecated use div instead. This was renamed for consistency with other languages like Kotlin
1506
*/
1507
@Deprecated(since = "2025", forRemoval = true)
1508
default Measure<?> divide(MomentOfInertia divisor) {
1509
return div(divisor);
1510
}
1511
1512
/**
1513
* Divides this measure by a generic multiplication and returns the result in the most appropriate
1514
* unit.
1515
*
1516
* @param divisor the measurement to divide by.
1517
* @return the division result
1518
* @deprecated use div instead. This was renamed for consistency with other languages like Kotlin
1519
*/
1520
@Deprecated(since = "2025", forRemoval = true)
1521
default Measure<?> divide(Mult<?, ?> divisor) {
1522
return div(divisor);
1523
}
1524
1525
/**
1526
* Divides this measure by a power and returns the result in the most appropriate unit.
1527
*
1528
* @param divisor the measurement to divide by.
1529
* @return the division result
1530
* @deprecated use div instead. This was renamed for consistency with other languages like Kotlin
1531
*/
1532
@Deprecated(since = "2025", forRemoval = true)
1533
default Measure<?> divide(Power divisor) {
1534
return div(divisor);
1535
}
1536
1537
/**
1538
* Divides this measure by a generic ratio and returns the result in the most appropriate unit.
1539
*
1540
* @param divisor the measurement to divide by.
1541
* @return the division result
1542
* @deprecated use div instead. This was renamed for consistency with other languages like Kotlin
1543
*/
1544
@Deprecated(since = "2025", forRemoval = true)
1545
default Measure<?> divide(Per<?, ?> divisor) {
1546
return div(divisor);
1547
}
1548
1549
/**
1550
* Divides this measure by a temperature and returns the result in the most appropriate unit.
1551
*
1552
* @param divisor the measurement to divide by.
1553
* @return the division result
1554
* @deprecated use div instead. This was renamed for consistency with other languages like Kotlin
1555
*/
1556
@Deprecated(since = "2025", forRemoval = true)
1557
default Measure<?> divide(Temperature divisor) {
1558
return div(divisor);
1559
}
1560
1561
/**
1562
* Divides this measure by a time and returns the result in the most appropriate unit. This will
1563
* often - but not always - result in a {@link Per} type like {@link LinearVelocity} or {@link
1564
* Acceleration}.
1565
*
1566
* @param divisor the measurement to divide by.
1567
* @return the division result
1568
* @deprecated use div instead. This was renamed for consistency with other languages like Kotlin
1569
*/
1570
@Deprecated(since = "2025", forRemoval = true)
1571
default Measure<?> divide(Time divisor) {
1572
return div(divisor);
1573
}
1574
1575
/**
1576
* Divides this measure by a torque and returns the result in the most appropriate unit.
1577
*
1578
* @param divisor the measurement to divide by.
1579
* @return the division result
1580
* @deprecated use div instead. This was renamed for consistency with other languages like Kotlin
1581
*/
1582
@Deprecated(since = "2025", forRemoval = true)
1583
default Measure<?> divide(Torque divisor) {
1584
return div(divisor);
1585
}
1586
1587
/**
1588
* Divides this measure by a generic velocity and returns the result in the most appropriate unit.
1589
*
1590
* @param divisor the measurement to divide by.
1591
* @return the division result
1592
* @deprecated use div instead. This was renamed for consistency with other languages like Kotlin
1593
*/
1594
@Deprecated(since = "2025", forRemoval = true)
1595
default Measure<?> divide(Velocity<?> divisor) {
1596
return div(divisor);
1597
}
1598
1599
/**
1600
* Divides this measure by a voltage and returns the result in the most appropriate unit.
1601
*
1602
* @param divisor the measurement to divide by.
1603
* @return the division result
1604
* @deprecated use div instead. This was renamed for consistency with other languages like Kotlin
1605
*/
1606
@Deprecated(since = "2025", forRemoval = true)
1607
default Measure<?> divide(Voltage divisor) {
1608
return div(divisor);
1609
}
1610
1611
/**
1612
* Divides this measure by a resistance and returns the result in the most appropriate unit.
1613
*
1614
* @param divisor the measurement to divide by.
1615
* @return the division result
1616
* @deprecated use div instead. This was renamed for consistency with other languages like Kotlin
1617
*/
1618
@Deprecated(since = "2025", forRemoval = true)
1619
default Measure<?> divide(Resistance divisor) {
1620
return div(divisor);
1621
}
1622
1623
/**
1624
* Divides this measure by a ratio in terms of this measurement's unit to another unit, returning
1625
* a measurement in terms of the other unit.
1626
*
1627
* @param divisor the measurement to divide by.
1628
* @param <Other> the other unit that results are in terms of
1629
* @return the division result
1630
*/
1631
// eg Dimensionless / (Dimensionless / Time) -> Time
1632
default <Other extends Unit> Measure<Other> divideRatio(
1633
Measure<? extends PerUnit<? extends U, Other>> divisor) {
1634
return ImmutableMeasure.ofBaseUnits(
1635
baseUnitMagnitude() / divisor.baseUnitMagnitude(), divisor.unit().denominator());
1636
}
1637
1638
/**
1639
* Checks if this measure is near another measure of the same unit. Provide a variance threshold
1640
* for use for a +/- scalar, such as 0.05 for +/- 5%.
1641
*
1642
* <pre>
1643
*   Inches.of(11).isNear(Inches.of(10), 0.1) // true
1644
*   Inches.of(12).isNear(Inches.of(10), 0.1) // false
1645
* </pre>
1646
*
1647
* @param other the other measurement to compare against
1648
* @param varianceThreshold the acceptable variance threshold, in terms of an acceptable +/- error
1649
*     range multiplier. Checking if a value is within 10% means a value of 0.1 should be passed;
1650
*     checking if a value is within 1% means a value of 0.01 should be passed, and so on.
1651
* @return true if this unit is near the other measure, otherwise false
1652
*/
1653
default boolean isNear(Measure<?> other, double varianceThreshold) {
1654
if (!this.unit().getBaseUnit().equivalent(other.unit().getBaseUnit())) {
1655
return false; // Disjoint units, not compatible
1656
}
1657
1658
// abs so negative inputs are calculated correctly
1659
var tolerance = Math.abs(other.baseUnitMagnitude() * varianceThreshold);
1660
1661
return Math.abs(this.baseUnitMagnitude() - other.baseUnitMagnitude()) <= tolerance;
1662
}
1663
1664
/**
1665
* Checks if this measure is near another measure of the same unit, with a specified tolerance of
1666
* the same unit.
1667
*
1668
* <pre>
1669
*     Meters.of(1).isNear(Meters.of(1.2), Millimeters.of(300)) // true
1670
*     Degrees.of(90).isNear(Rotations.of(0.5), Degrees.of(45)) // false
1671
* </pre>
1672
*
1673
* @param other the other measure to compare against.
1674
* @param tolerance the tolerance allowed in which the two measures are defined as near each
1675
*     other.
1676
* @return true if this unit is near the other measure, otherwise false.
1677
*/
1678
default boolean isNear(Measure<U> other, Measure<U> tolerance) {
1679
return Math.abs(this.baseUnitMagnitude() - other.baseUnitMagnitude())
1680
<= Math.abs(tolerance.baseUnitMagnitude());
1681
}
1682
1683
/**
1684
* Checks if this measure is equivalent to another measure of the same unit.
1685
*
1686
* @param other the measure to compare to
1687
* @return true if this measure is equivalent, false otherwise
1688
*/
1689
default boolean isEquivalent(Measure<?> other) {
1690
// Return false for disjoint units that aren't compatible
1691
return this.unit().getBaseUnit().equals(other.unit().getBaseUnit())
1692
&& Math.abs(baseUnitMagnitude() - other.baseUnitMagnitude()) <= EQUIVALENCE_THRESHOLD;
1693
}
1694
1695
/** {@inheritDoc} */
1696
@Override
1697
default int compareTo(Measure<U> o) {
1698
return Double.compare(this.baseUnitMagnitude(), o.baseUnitMagnitude());
1699
}
1700
1701
/**
1702
* Checks if this measure is greater than another measure of the same unit.
1703
*
1704
* @param o the other measure to compare to
1705
* @return true if this measure has a greater equivalent magnitude, false otherwise
1706
*/
1707
default boolean gt(Measure<U> o) {
1708
return compareTo(o) > 0;
1709
}
1710
1711
/**
1712
* Checks if this measure is greater than or equivalent to another measure of the same unit.
1713
*
1714
* @param o the other measure to compare to
1715
* @return true if this measure has an equal or greater equivalent magnitude, false otherwise
1716
*/
1717
default boolean gte(Measure<U> o) {
1718
return compareTo(o) > 0 || isEquivalent(o);
1719
}
1720
1721
/**
1722
* Checks if this measure is less than another measure of the same unit.
1723
*
1724
* @param o the other measure to compare to
1725
* @return true if this measure has a lesser equivalent magnitude, false otherwise
1726
*/
1727
default boolean lt(Measure<U> o) {
1728
return compareTo(o) < 0;
1729
}
1730
1731
/**
1732
* Checks if this measure is less than or equivalent to another measure of the same unit.
1733
*
1734
* @param o the other measure to compare to
1735
* @return true if this measure has an equal or lesser equivalent magnitude, false otherwise
1736
*/
1737
default boolean lte(Measure<U> o) {
1738
return compareTo(o) < 0 || isEquivalent(o);
1739
}
1740
1741
/**
1742
* Returns the measure with the absolute value closest to positive infinity.
1743
*
1744
* @param <U> the type of the units of the measures
1745
* @param measures the set of measures to compare
1746
* @return the measure with the greatest positive magnitude, or null if no measures were provided
1747
*/
1748
@SafeVarargs
1749
static <U extends Unit> Measure<U> max(Measure<U>... measures) {
1750
if (measures.length == 0) {
1751
return null; // nothing to compare
1752
}
1753
1754
Measure<U> max = null;
1755
for (Measure<U> measure : measures) {
1756
if (max == null || measure.gt(max)) {
1757
max = measure;
1758
}
1759
}
1760
1761
return max;
1762
}
1763
1764
/**
1765
* Returns the measure with the absolute value closest to negative infinity.
1766
*
1767
* @param <U> the type of the units of the measures
1768
* @param measures the set of measures to compare
1769
* @return the measure with the greatest negative magnitude
1770
*/
1771
@SafeVarargs
1772
static <U extends Unit> Measure<U> min(Measure<U>... measures) {
1773
if (measures.length == 0) {
1774
return null; // nothing to compare
1775
}
1776
1777
Measure<U> max = null;
1778
for (Measure<U> measure : measures) {
1779
if (max == null || measure.lt(max)) {
1780
max = measure;
1781
}
1782
}
1783
1784
return max;
1785
}
1786
1787
/**
1788
* Returns a string representation of this measurement in a shorthand form. The symbol of the
1789
* backing unit is used, rather than the full name, and the magnitude is represented in scientific
1790
* notation.
1791
*
1792
* @return the short form representation of this measurement
1793
*/
1794
default String toShortString() {
1795
// eg 1.234e+04 V/m (1234 Volt per Meter in long form)
1796
return String.format("%.3e %s", magnitude(), unit().symbol());
1797
}
1798
1799
/**
1800
* Returns a string representation of this measurement in a longhand form. The name of the backing
1801
* unit is used, rather than its symbol, and the magnitude is represented in a full string, not
1802
* scientific notation. (Very large values may be represented in scientific notation, however)
1803
*
1804
* @return the long form representation of this measurement
1805
*/
1806
default String toLongString() {
1807
// eg 1234 Volt per Meter (1.234e+04 V/m in short form)
1808
return String.format("%s %s", magnitude(), unit().name());
1809
}
1810
}