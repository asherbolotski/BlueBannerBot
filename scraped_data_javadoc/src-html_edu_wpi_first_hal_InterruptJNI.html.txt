001
// Copyright (c) FIRST and other WPILib contributors.
002
// Open Source Software; you can modify and/or share it under the terms of
003
// the WPILib BSD license file in the root directory of this project.
004
005
package edu.wpi.first.hal;
006
007
/**
008
* Interrupt HAL JNI functions.
009
*
010
* @see "hal/Interrupts.h"
011
*/
012
public class InterruptJNI extends JNIWrapper {
013
/** Invalid handle value. */
014
public static final int HalInvalidHandle = 0;
015
016
/**
017
* Initializes an interrupt.
018
*
019
* @return the created interrupt handle
020
* @see "HAL_InitializeInterrupts"
021
*/
022
public static native int initializeInterrupts();
023
024
/**
025
* Frees an interrupt.
026
*
027
* @param interruptHandle the interrupt handle
028
* @see "HAL_CleanInterrupts"
029
*/
030
public static native void cleanInterrupts(int interruptHandle);
031
032
/**
033
* Waits for the defined interrupt to occur.
034
*
035
* @param interruptHandle the interrupt handle
036
* @param timeout timeout in seconds
037
* @param ignorePrevious if true, ignore interrupts that happened before waitForInterrupt was
038
*     called
039
* @return the mask of interrupts that fired
040
* @see "HAL_WaitForInterrupt"
041
*/
042
public static native long waitForInterrupt(
043
int interruptHandle, double timeout, boolean ignorePrevious);
044
045
/**
046
* Waits for any interrupt covered by the mask to occur.
047
*
048
* @param interruptHandle the interrupt handle to use for the context
049
* @param mask the mask of interrupts to wait for
050
* @param timeout timeout in seconds
051
* @param ignorePrevious if true, ignore interrupts that happened before waitForInterrupt was
052
*     called
053
* @return the mask of interrupts that fired
054
* @see "HAL_WaitForMultipleInterrupts"
055
*/
056
public static native long waitForMultipleInterrupts(
057
int interruptHandle, long mask, double timeout, boolean ignorePrevious);
058
059
/**
060
* Returns the timestamp for the rising interrupt that occurred most recently.
061
*
062
* <p>This is in the same time domain as getFPGATime(). It only contains the bottom 32 bits of the
063
* timestamp. If your robot has been running for over 1 hour, you will need to fill in the upper
064
* 32 bits yourself.
065
*
066
* @param interruptHandle the interrupt handle
067
* @return timestamp in microseconds since FPGA Initialization
068
*/
069
public static native long readInterruptRisingTimestamp(int interruptHandle);
070
071
/**
072
* Returns the timestamp for the falling interrupt that occurred most recently.
073
*
074
* <p>This is in the same time domain as getFPGATime(). It only contains the bottom 32 bits of the
075
* timestamp. If your robot has been running for over 1 hour, you will need to fill in the upper
076
* 32 bits yourself.
077
*
078
* @param interruptHandle the interrupt handle
079
* @return timestamp in microseconds since FPGA Initialization
080
*/
081
public static native long readInterruptFallingTimestamp(int interruptHandle);
082
083
/**
084
* Requests interrupts on a specific digital source.
085
*
086
* @param interruptHandle the interrupt handle
087
* @param digitalSourceHandle the digital source handle (either a HAL_AnalogTriggerHandle or a
088
*     HAL_DigitalHandle)
089
* @param analogTriggerType the trigger type if the source is an AnalogTrigger
090
* @see "HAL_RequestInterrupts"
091
*/
092
public static native void requestInterrupts(
093
int interruptHandle, int digitalSourceHandle, int analogTriggerType);
094
095
/**
096
* Sets the edges to trigger the interrupt on.
097
*
098
* <p>Note that both edges triggered is a valid configuration.
099
*
100
* @param interruptHandle the interrupt handle
101
* @param risingEdge true for triggering on rising edge
102
* @param fallingEdge true for triggering on falling edge
103
* @see "HAL_SetInterruptUpSourceEdge"
104
*/
105
public static native void setInterruptUpSourceEdge(
106
int interruptHandle, boolean risingEdge, boolean fallingEdge);
107
108
/**
109
* Releases a waiting interrupt.
110
*
111
* <p>This will release both rising and falling waiters.
112
*
113
* @param interruptHandle the interrupt handle to release
114
* @see "HAL_ReleaseWaitingInterrupt"
115
*/
116
public static native void releaseWaitingInterrupt(int interruptHandle);
117
118
/** Utility class. */
119
private InterruptJNI() {}
120
}