001
// Copyright (c) FIRST and other WPILib contributors.
002
// Open Source Software; you can modify and/or share it under the terms of
003
// the WPILib BSD license file in the root directory of this project.
004
005
package edu.wpi.first.wpilibj.simulation;
006
007
import edu.wpi.first.hal.simulation.AnalogInDataJNI;
008
import edu.wpi.first.hal.simulation.NotifyCallback;
009
import edu.wpi.first.wpilibj.AnalogInput;
010
011
/** Class to control a simulated analog input. */
012
public class AnalogInputSim {
013
private final int m_index;
014
015
/**
016
* Constructs from an AnalogInput object.
017
*
018
* @param analogInput AnalogInput to simulate
019
*/
020
public AnalogInputSim(AnalogInput analogInput) {
021
m_index = analogInput.getChannel();
022
}
023
024
/**
025
* Constructs from an analog input channel number.
026
*
027
* @param channel Channel number
028
*/
029
public AnalogInputSim(int channel) {
030
m_index = channel;
031
}
032
033
/**
034
* Register a callback on whether the analog input is initialized.
035
*
036
* @param callback the callback that will be called whenever the analog input is initialized
037
* @param initialNotify if true, the callback will be run on the initial value
038
* @return the {@link CallbackStore} object associated with this callback.
039
*/
040
public CallbackStore registerInitializedCallback(NotifyCallback callback, boolean initialNotify) {
041
int uid = AnalogInDataJNI.registerInitializedCallback(m_index, callback, initialNotify);
042
return new CallbackStore(m_index, uid, AnalogInDataJNI::cancelInitializedCallback);
043
}
044
045
/**
046
* Check if this analog input has been initialized.
047
*
048
* @return true if initialized
049
*/
050
public boolean getInitialized() {
051
return AnalogInDataJNI.getInitialized(m_index);
052
}
053
054
/**
055
* Change whether this analog input has been initialized.
056
*
057
* @param initialized the new value
058
*/
059
public void setInitialized(boolean initialized) {
060
AnalogInDataJNI.setInitialized(m_index, initialized);
061
}
062
063
/**
064
* Register a callback on the number of average bits.
065
*
066
* @param callback the callback that will be called whenever the number of average bits is changed
067
* @param initialNotify if true, the callback will be run on the initial value
068
* @return the {@link CallbackStore} object associated with this callback.
069
*/
070
public CallbackStore registerAverageBitsCallback(NotifyCallback callback, boolean initialNotify) {
071
int uid = AnalogInDataJNI.registerAverageBitsCallback(m_index, callback, initialNotify);
072
return new CallbackStore(m_index, uid, AnalogInDataJNI::cancelAverageBitsCallback);
073
}
074
075
/**
076
* Get the number of average bits.
077
*
078
* @return the number of average bits
079
*/
080
public int getAverageBits() {
081
return AnalogInDataJNI.getAverageBits(m_index);
082
}
083
084
/**
085
* Change the number of average bits.
086
*
087
* @param averageBits the new value
088
*/
089
public void setAverageBits(int averageBits) {
090
AnalogInDataJNI.setAverageBits(m_index, averageBits);
091
}
092
093
/**
094
* Register a callback on the amount of oversampling bits.
095
*
096
* @param callback the callback that will be called whenever the oversampling bits are changed.
097
* @param initialNotify if true, the callback will be run on the initial value
098
* @return the {@link CallbackStore} object associated with this callback.
099
*/
100
public CallbackStore registerOversampleBitsCallback(
101
NotifyCallback callback, boolean initialNotify) {
102
int uid = AnalogInDataJNI.registerOversampleBitsCallback(m_index, callback, initialNotify);
103
return new CallbackStore(m_index, uid, AnalogInDataJNI::cancelOversampleBitsCallback);
104
}
105
106
/**
107
* Get the amount of oversampling bits.
108
*
109
* @return the amount of oversampling bits
110
*/
111
public int getOversampleBits() {
112
return AnalogInDataJNI.getOversampleBits(m_index);
113
}
114
115
/**
116
* Change the amount of oversampling bits.
117
*
118
* @param oversampleBits the new value
119
*/
120
public void setOversampleBits(int oversampleBits) {
121
AnalogInDataJNI.setOversampleBits(m_index, oversampleBits);
122
}
123
124
/**
125
* Register a callback on the voltage.
126
*
127
* @param callback the callback that will be called whenever the voltage is changed.
128
* @param initialNotify if true, the callback will be run on the initial value
129
* @return the {@link CallbackStore} object associated with this callback.
130
*/
131
public CallbackStore registerVoltageCallback(NotifyCallback callback, boolean initialNotify) {
132
int uid = AnalogInDataJNI.registerVoltageCallback(m_index, callback, initialNotify);
133
return new CallbackStore(m_index, uid, AnalogInDataJNI::cancelVoltageCallback);
134
}
135
136
/**
137
* Get the voltage.
138
*
139
* @return the voltage
140
*/
141
public double getVoltage() {
142
return AnalogInDataJNI.getVoltage(m_index);
143
}
144
145
/**
146
* Change the voltage.
147
*
148
* @param voltage the new value
149
*/
150
public void setVoltage(double voltage) {
151
AnalogInDataJNI.setVoltage(m_index, voltage);
152
}
153
154
/**
155
* Register a callback on whether the accumulator is initialized.
156
*
157
* @param callback the callback that will be called whenever the accumulator is initialized
158
* @param initialNotify if true, the callback will be run on the initial value
159
* @return the {@link CallbackStore} object associated with this callback.
160
*/
161
public CallbackStore registerAccumulatorInitializedCallback(
162
NotifyCallback callback, boolean initialNotify) {
163
int uid =
164
AnalogInDataJNI.registerAccumulatorInitializedCallback(m_index, callback, initialNotify);
165
return new CallbackStore(m_index, uid, AnalogInDataJNI::cancelAccumulatorInitializedCallback);
166
}
167
168
/**
169
* Check if the accumulator has been initialized.
170
*
171
* @return true if initialized
172
*/
173
public boolean getAccumulatorInitialized() {
174
return AnalogInDataJNI.getAccumulatorInitialized(m_index);
175
}
176
177
/**
178
* Change whether the accumulator has been initialized.
179
*
180
* @param accumulatorInitialized the new value
181
*/
182
public void setAccumulatorInitialized(boolean accumulatorInitialized) {
183
AnalogInDataJNI.setAccumulatorInitialized(m_index, accumulatorInitialized);
184
}
185
186
/**
187
* Register a callback on the accumulator value.
188
*
189
* @param callback the callback that will be called whenever the accumulator value is changed.
190
* @param initialNotify if true, the callback will be run on the initial value
191
* @return the {@link CallbackStore} object associated with this callback.
192
*/
193
public CallbackStore registerAccumulatorValueCallback(
194
NotifyCallback callback, boolean initialNotify) {
195
int uid = AnalogInDataJNI.registerAccumulatorValueCallback(m_index, callback, initialNotify);
196
return new CallbackStore(m_index, uid, AnalogInDataJNI::cancelAccumulatorValueCallback);
197
}
198
199
/**
200
* Get the accumulator value.
201
*
202
* @return the accumulator value
203
*/
204
public long getAccumulatorValue() {
205
return AnalogInDataJNI.getAccumulatorValue(m_index);
206
}
207
208
/**
209
* Change the accumulator value.
210
*
211
* @param accumulatorValue the new value
212
*/
213
public void setAccumulatorValue(long accumulatorValue) {
214
AnalogInDataJNI.setAccumulatorValue(m_index, accumulatorValue);
215
}
216
217
/**
218
* Register a callback on the accumulator count.
219
*
220
* @param callback the callback that will be called whenever the accumulator count is changed.
221
* @param initialNotify if true, the callback will be run on the initial value
222
* @return the {@link CallbackStore} object associated with this callback.
223
*/
224
public CallbackStore registerAccumulatorCountCallback(
225
NotifyCallback callback, boolean initialNotify) {
226
int uid = AnalogInDataJNI.registerAccumulatorCountCallback(m_index, callback, initialNotify);
227
return new CallbackStore(m_index, uid, AnalogInDataJNI::cancelAccumulatorCountCallback);
228
}
229
230
/**
231
* Get the accumulator count.
232
*
233
* @return the accumulator count.
234
*/
235
public long getAccumulatorCount() {
236
return AnalogInDataJNI.getAccumulatorCount(m_index);
237
}
238
239
/**
240
* Change the accumulator count.
241
*
242
* @param accumulatorCount the new count.
243
*/
244
public void setAccumulatorCount(long accumulatorCount) {
245
AnalogInDataJNI.setAccumulatorCount(m_index, accumulatorCount);
246
}
247
248
/**
249
* Register a callback on the accumulator center.
250
*
251
* @param callback the callback that will be called whenever the accumulator center is changed
252
* @param initialNotify if true, the callback will be run on the initial value
253
* @return the {@link CallbackStore} object associated with this callback.
254
*/
255
public CallbackStore registerAccumulatorCenterCallback(
256
NotifyCallback callback, boolean initialNotify) {
257
int uid = AnalogInDataJNI.registerAccumulatorCenterCallback(m_index, callback, initialNotify);
258
return new CallbackStore(m_index, uid, AnalogInDataJNI::cancelAccumulatorCenterCallback);
259
}
260
261
/**
262
* Get the accumulator center.
263
*
264
* @return the accumulator center
265
*/
266
public int getAccumulatorCenter() {
267
return AnalogInDataJNI.getAccumulatorCenter(m_index);
268
}
269
270
/**
271
* Change the accumulator center.
272
*
273
* @param accumulatorCenter the new center
274
*/
275
public void setAccumulatorCenter(int accumulatorCenter) {
276
AnalogInDataJNI.setAccumulatorCenter(m_index, accumulatorCenter);
277
}
278
279
/**
280
* Register a callback on the accumulator deadband.
281
*
282
* @param callback the callback that will be called whenever the accumulator deadband is changed
283
* @param initialNotify if true, the callback will be run on the initial value
284
* @return the {@link CallbackStore} object associated with this callback.
285
*/
286
public CallbackStore registerAccumulatorDeadbandCallback(
287
NotifyCallback callback, boolean initialNotify) {
288
int uid = AnalogInDataJNI.registerAccumulatorDeadbandCallback(m_index, callback, initialNotify);
289
return new CallbackStore(m_index, uid, AnalogInDataJNI::cancelAccumulatorDeadbandCallback);
290
}
291
292
/**
293
* Get the accumulator deadband.
294
*
295
* @return the accumulator deadband
296
*/
297
public int getAccumulatorDeadband() {
298
return AnalogInDataJNI.getAccumulatorDeadband(m_index);
299
}
300
301
/**
302
* Change the accumulator deadband.
303
*
304
* @param accumulatorDeadband the new deadband
305
*/
306
public void setAccumulatorDeadband(int accumulatorDeadband) {
307
AnalogInDataJNI.setAccumulatorDeadband(m_index, accumulatorDeadband);
308
}
309
310
/** Reset all simulation data for this object. */
311
public void resetData() {
312
AnalogInDataJNI.resetData(m_index);
313
}
314
}