001
// Copyright (c) FIRST and other WPILib contributors.
002
// Open Source Software; you can modify and/or share it under the terms of
003
// the WPILib BSD license file in the root directory of this project.
004
005
// THIS FILE WAS AUTO-GENERATED BY ./ntcore/generate_topics.py. DO NOT MODIFY
006
007
package edu.wpi.first.networktables;
008
009
import java.util.Objects;
010
011
/** A network table entry value. */
012
@SuppressWarnings({"UnnecessaryParentheses", "PMD.MethodReturnsInternalArray"})
013
public final class NetworkTableValue {
014
NetworkTableValue(NetworkTableType type, Object value, long time, long serverTime) {
015
m_type = type;
016
m_value = value;
017
m_time = time;
018
m_serverTime = serverTime;
019
}
020
021
NetworkTableValue(NetworkTableType type, Object value, long time) {
022
this(type, value, time, time == 0 ? 0 : 1);
023
}
024
025
NetworkTableValue(NetworkTableType type, Object value) {
026
this(type, value, NetworkTablesJNI.now(), 1);
027
}
028
029
NetworkTableValue(int type, Object value, long time, long serverTime) {
030
this(NetworkTableType.getFromInt(type), value, time, serverTime);
031
}
032
033
/**
034
* Get the data type.
035
*
036
* @return The type.
037
*/
038
public NetworkTableType getType() {
039
return m_type;
040
}
041
042
/**
043
* Get the data value stored.
044
*
045
* @return The type.
046
*/
047
public Object getValue() {
048
return m_value;
049
}
050
051
/**
052
* Get the creation time of the value in local time.
053
*
054
* @return The time, in the units returned by NetworkTablesJNI.now().
055
*/
056
public long getTime() {
057
return m_time;
058
}
059
060
/**
061
* Get the creation time of the value in server time.
062
*
063
* @return The server time.
064
*/
065
public long getServerTime() {
066
return m_serverTime;
067
}
068
069
/*
070
* Type Checkers
071
*/
072
073
/**
074
* Determine if entry value contains a value or is unassigned.
075
*
076
* @return True if the entry value contains a value.
077
*/
078
public boolean isValid() {
079
return m_type != NetworkTableType.kUnassigned;
080
}
081
082
/**
083
* Determine if entry value contains a boolean.
084
*
085
* @return True if the entry value is of boolean type.
086
*/
087
public boolean isBoolean() {
088
return m_type == NetworkTableType.kBoolean;
089
}
090
091
/**
092
* Determine if entry value contains a long.
093
*
094
* @return True if the entry value is of long type.
095
*/
096
public boolean isInteger() {
097
return m_type == NetworkTableType.kInteger;
098
}
099
100
/**
101
* Determine if entry value contains a float.
102
*
103
* @return True if the entry value is of float type.
104
*/
105
public boolean isFloat() {
106
return m_type == NetworkTableType.kFloat;
107
}
108
109
/**
110
* Determine if entry value contains a double.
111
*
112
* @return True if the entry value is of double type.
113
*/
114
public boolean isDouble() {
115
return m_type == NetworkTableType.kDouble;
116
}
117
118
/**
119
* Determine if entry value contains a String.
120
*
121
* @return True if the entry value is of String type.
122
*/
123
public boolean isString() {
124
return m_type == NetworkTableType.kString;
125
}
126
127
/**
128
* Determine if entry value contains a byte[].
129
*
130
* @return True if the entry value is of byte[] type.
131
*/
132
public boolean isRaw() {
133
return m_type == NetworkTableType.kRaw;
134
}
135
136
/**
137
* Determine if entry value contains a boolean[].
138
*
139
* @return True if the entry value is of boolean[] type.
140
*/
141
public boolean isBooleanArray() {
142
return m_type == NetworkTableType.kBooleanArray;
143
}
144
145
/**
146
* Determine if entry value contains a long[].
147
*
148
* @return True if the entry value is of long[] type.
149
*/
150
public boolean isIntegerArray() {
151
return m_type == NetworkTableType.kIntegerArray;
152
}
153
154
/**
155
* Determine if entry value contains a float[].
156
*
157
* @return True if the entry value is of float[] type.
158
*/
159
public boolean isFloatArray() {
160
return m_type == NetworkTableType.kFloatArray;
161
}
162
163
/**
164
* Determine if entry value contains a double[].
165
*
166
* @return True if the entry value is of double[] type.
167
*/
168
public boolean isDoubleArray() {
169
return m_type == NetworkTableType.kDoubleArray;
170
}
171
172
/**
173
* Determine if entry value contains a String[].
174
*
175
* @return True if the entry value is of String[] type.
176
*/
177
public boolean isStringArray() {
178
return m_type == NetworkTableType.kStringArray;
179
}
180
181
/*
182
* Type-Safe Getters
183
*/
184
185
/**
186
* Get the boolean value.
187
*
188
* @return The boolean value.
189
* @throws ClassCastException if the entry value is not of boolean type.
190
*/
191
public boolean getBoolean() {
192
if (m_type != NetworkTableType.kBoolean) {
193
throw new ClassCastException("cannot convert " + m_type + " to boolean");
194
}
195
return (Boolean) m_value;
196
}
197
198
/**
199
* Get the long value.
200
*
201
* @return The long value.
202
* @throws ClassCastException if the entry value is not of long type.
203
*/
204
public long getInteger() {
205
if (m_type != NetworkTableType.kInteger) {
206
throw new ClassCastException("cannot convert " + m_type + " to long");
207
}
208
return ((Number) m_value).longValue();
209
}
210
211
/**
212
* Get the float value.
213
*
214
* @return The float value.
215
* @throws ClassCastException if the entry value is not of float type.
216
*/
217
public float getFloat() {
218
if (m_type != NetworkTableType.kFloat) {
219
throw new ClassCastException("cannot convert " + m_type + " to float");
220
}
221
return ((Number) m_value).floatValue();
222
}
223
224
/**
225
* Get the double value.
226
*
227
* @return The double value.
228
* @throws ClassCastException if the entry value is not of double type.
229
*/
230
public double getDouble() {
231
if (m_type != NetworkTableType.kDouble) {
232
throw new ClassCastException("cannot convert " + m_type + " to double");
233
}
234
return ((Number) m_value).doubleValue();
235
}
236
237
/**
238
* Get the String value.
239
*
240
* @return The String value.
241
* @throws ClassCastException if the entry value is not of String type.
242
*/
243
public String getString() {
244
if (m_type != NetworkTableType.kString) {
245
throw new ClassCastException("cannot convert " + m_type + " to String");
246
}
247
return (String) m_value;
248
}
249
250
/**
251
* Get the byte[] value.
252
*
253
* @return The byte[] value.
254
* @throws ClassCastException if the entry value is not of byte[] type.
255
*/
256
public byte[] getRaw() {
257
if (m_type != NetworkTableType.kRaw) {
258
throw new ClassCastException("cannot convert " + m_type + " to byte[]");
259
}
260
return (byte[]) m_value;
261
}
262
263
/**
264
* Get the boolean[] value.
265
*
266
* @return The boolean[] value.
267
* @throws ClassCastException if the entry value is not of boolean[] type.
268
*/
269
public boolean[] getBooleanArray() {
270
if (m_type != NetworkTableType.kBooleanArray) {
271
throw new ClassCastException("cannot convert " + m_type + " to boolean[]");
272
}
273
return (boolean[]) m_value;
274
}
275
276
/**
277
* Get the long[] value.
278
*
279
* @return The long[] value.
280
* @throws ClassCastException if the entry value is not of long[] type.
281
*/
282
public long[] getIntegerArray() {
283
if (m_type != NetworkTableType.kIntegerArray) {
284
throw new ClassCastException("cannot convert " + m_type + " to long[]");
285
}
286
return (long[]) m_value;
287
}
288
289
/**
290
* Get the float[] value.
291
*
292
* @return The float[] value.
293
* @throws ClassCastException if the entry value is not of float[] type.
294
*/
295
public float[] getFloatArray() {
296
if (m_type != NetworkTableType.kFloatArray) {
297
throw new ClassCastException("cannot convert " + m_type + " to float[]");
298
}
299
return (float[]) m_value;
300
}
301
302
/**
303
* Get the double[] value.
304
*
305
* @return The double[] value.
306
* @throws ClassCastException if the entry value is not of double[] type.
307
*/
308
public double[] getDoubleArray() {
309
if (m_type != NetworkTableType.kDoubleArray) {
310
throw new ClassCastException("cannot convert " + m_type + " to double[]");
311
}
312
return (double[]) m_value;
313
}
314
315
/**
316
* Get the String[] value.
317
*
318
* @return The String[] value.
319
* @throws ClassCastException if the entry value is not of String[] type.
320
*/
321
public String[] getStringArray() {
322
if (m_type != NetworkTableType.kStringArray) {
323
throw new ClassCastException("cannot convert " + m_type + " to String[]");
324
}
325
return (String[]) m_value;
326
}
327
328
/*
329
* Factory functions.
330
*/
331
332
/**
333
* Creates a boolean value.
334
*
335
* @param value the value
336
* @return The entry value
337
*/
338
public static NetworkTableValue makeBoolean(boolean value) {
339
return new NetworkTableValue(NetworkTableType.kBoolean, Boolean.valueOf(value));
340
}
341
342
/**
343
* Creates a boolean value.
344
*
345
* @param value the value
346
* @param time the creation time to use (instead of the current time)
347
* @return The entry value
348
*/
349
public static NetworkTableValue makeBoolean(boolean value, long time) {
350
return new NetworkTableValue(NetworkTableType.kBoolean, Boolean.valueOf(value), time);
351
}
352
353
/**
354
* Creates a long value.
355
*
356
* @param value the value
357
* @return The entry value
358
*/
359
public static NetworkTableValue makeInteger(long value) {
360
return new NetworkTableValue(NetworkTableType.kInteger, Long.valueOf(value));
361
}
362
363
/**
364
* Creates a long value.
365
*
366
* @param value the value
367
* @param time the creation time to use (instead of the current time)
368
* @return The entry value
369
*/
370
public static NetworkTableValue makeInteger(long value, long time) {
371
return new NetworkTableValue(NetworkTableType.kInteger, Long.valueOf(value), time);
372
}
373
374
/**
375
* Creates a float value.
376
*
377
* @param value the value
378
* @return The entry value
379
*/
380
public static NetworkTableValue makeFloat(float value) {
381
return new NetworkTableValue(NetworkTableType.kFloat, Float.valueOf(value));
382
}
383
384
/**
385
* Creates a float value.
386
*
387
* @param value the value
388
* @param time the creation time to use (instead of the current time)
389
* @return The entry value
390
*/
391
public static NetworkTableValue makeFloat(float value, long time) {
392
return new NetworkTableValue(NetworkTableType.kFloat, Float.valueOf(value), time);
393
}
394
395
/**
396
* Creates a double value.
397
*
398
* @param value the value
399
* @return The entry value
400
*/
401
public static NetworkTableValue makeDouble(double value) {
402
return new NetworkTableValue(NetworkTableType.kDouble, Double.valueOf(value));
403
}
404
405
/**
406
* Creates a double value.
407
*
408
* @param value the value
409
* @param time the creation time to use (instead of the current time)
410
* @return The entry value
411
*/
412
public static NetworkTableValue makeDouble(double value, long time) {
413
return new NetworkTableValue(NetworkTableType.kDouble, Double.valueOf(value), time);
414
}
415
416
/**
417
* Creates a String value.
418
*
419
* @param value the value
420
* @return The entry value
421
*/
422
public static NetworkTableValue makeString(String value) {
423
return new NetworkTableValue(NetworkTableType.kString, (value));
424
}
425
426
/**
427
* Creates a String value.
428
*
429
* @param value the value
430
* @param time the creation time to use (instead of the current time)
431
* @return The entry value
432
*/
433
public static NetworkTableValue makeString(String value, long time) {
434
return new NetworkTableValue(NetworkTableType.kString, (value), time);
435
}
436
437
/**
438
* Creates a byte[] value.
439
*
440
* @param value the value
441
* @return The entry value
442
*/
443
public static NetworkTableValue makeRaw(byte[] value) {
444
return new NetworkTableValue(NetworkTableType.kRaw, (value));
445
}
446
447
/**
448
* Creates a byte[] value.
449
*
450
* @param value the value
451
* @param time the creation time to use (instead of the current time)
452
* @return The entry value
453
*/
454
public static NetworkTableValue makeRaw(byte[] value, long time) {
455
return new NetworkTableValue(NetworkTableType.kRaw, (value), time);
456
}
457
458
/**
459
* Creates a boolean[] value.
460
*
461
* @param value the value
462
* @return The entry value
463
*/
464
public static NetworkTableValue makeBooleanArray(boolean[] value) {
465
return new NetworkTableValue(NetworkTableType.kBooleanArray, (value));
466
}
467
468
/**
469
* Creates a boolean[] value.
470
*
471
* @param value the value
472
* @param time the creation time to use (instead of the current time)
473
* @return The entry value
474
*/
475
public static NetworkTableValue makeBooleanArray(boolean[] value, long time) {
476
return new NetworkTableValue(NetworkTableType.kBooleanArray, (value), time);
477
}
478
479
/**
480
* Creates a boolean[] value.
481
*
482
* @param value the value
483
* @return The entry value
484
*/
485
public static NetworkTableValue makeBooleanArray(Boolean[] value) {
486
return new NetworkTableValue(NetworkTableType.kBooleanArray, toNativeBooleanArray(value));
487
}
488
489
/**
490
* Creates a boolean[] value.
491
*
492
* @param value the value
493
* @param time the creation time to use (instead of the current time)
494
* @return The entry value
495
*/
496
public static NetworkTableValue makeBooleanArray(Boolean[] value, long time) {
497
return new NetworkTableValue(NetworkTableType.kBooleanArray, toNativeBooleanArray(value), time);
498
}
499
500
/**
501
* Creates a long[] value.
502
*
503
* @param value the value
504
* @return The entry value
505
*/
506
public static NetworkTableValue makeIntegerArray(long[] value) {
507
return new NetworkTableValue(NetworkTableType.kIntegerArray, (value));
508
}
509
510
/**
511
* Creates a long[] value.
512
*
513
* @param value the value
514
* @param time the creation time to use (instead of the current time)
515
* @return The entry value
516
*/
517
public static NetworkTableValue makeIntegerArray(long[] value, long time) {
518
return new NetworkTableValue(NetworkTableType.kIntegerArray, (value), time);
519
}
520
521
/**
522
* Creates a long[] value.
523
*
524
* @param value the value
525
* @return The entry value
526
*/
527
public static NetworkTableValue makeIntegerArray(Long[] value) {
528
return new NetworkTableValue(NetworkTableType.kIntegerArray, toNativeIntegerArray(value));
529
}
530
531
/**
532
* Creates a long[] value.
533
*
534
* @param value the value
535
* @param time the creation time to use (instead of the current time)
536
* @return The entry value
537
*/
538
public static NetworkTableValue makeIntegerArray(Long[] value, long time) {
539
return new NetworkTableValue(NetworkTableType.kIntegerArray, toNativeIntegerArray(value), time);
540
}
541
542
/**
543
* Creates a float[] value.
544
*
545
* @param value the value
546
* @return The entry value
547
*/
548
public static NetworkTableValue makeFloatArray(float[] value) {
549
return new NetworkTableValue(NetworkTableType.kFloatArray, (value));
550
}
551
552
/**
553
* Creates a float[] value.
554
*
555
* @param value the value
556
* @param time the creation time to use (instead of the current time)
557
* @return The entry value
558
*/
559
public static NetworkTableValue makeFloatArray(float[] value, long time) {
560
return new NetworkTableValue(NetworkTableType.kFloatArray, (value), time);
561
}
562
563
/**
564
* Creates a float[] value.
565
*
566
* @param value the value
567
* @return The entry value
568
*/
569
public static NetworkTableValue makeFloatArray(Float[] value) {
570
return new NetworkTableValue(NetworkTableType.kFloatArray, toNativeFloatArray(value));
571
}
572
573
/**
574
* Creates a float[] value.
575
*
576
* @param value the value
577
* @param time the creation time to use (instead of the current time)
578
* @return The entry value
579
*/
580
public static NetworkTableValue makeFloatArray(Float[] value, long time) {
581
return new NetworkTableValue(NetworkTableType.kFloatArray, toNativeFloatArray(value), time);
582
}
583
584
/**
585
* Creates a double[] value.
586
*
587
* @param value the value
588
* @return The entry value
589
*/
590
public static NetworkTableValue makeDoubleArray(double[] value) {
591
return new NetworkTableValue(NetworkTableType.kDoubleArray, (value));
592
}
593
594
/**
595
* Creates a double[] value.
596
*
597
* @param value the value
598
* @param time the creation time to use (instead of the current time)
599
* @return The entry value
600
*/
601
public static NetworkTableValue makeDoubleArray(double[] value, long time) {
602
return new NetworkTableValue(NetworkTableType.kDoubleArray, (value), time);
603
}
604
605
/**
606
* Creates a double[] value.
607
*
608
* @param value the value
609
* @return The entry value
610
*/
611
public static NetworkTableValue makeDoubleArray(Double[] value) {
612
return new NetworkTableValue(NetworkTableType.kDoubleArray, toNativeDoubleArray(value));
613
}
614
615
/**
616
* Creates a double[] value.
617
*
618
* @param value the value
619
* @param time the creation time to use (instead of the current time)
620
* @return The entry value
621
*/
622
public static NetworkTableValue makeDoubleArray(Double[] value, long time) {
623
return new NetworkTableValue(NetworkTableType.kDoubleArray, toNativeDoubleArray(value), time);
624
}
625
626
/**
627
* Creates a String[] value.
628
*
629
* @param value the value
630
* @return The entry value
631
*/
632
public static NetworkTableValue makeStringArray(String[] value) {
633
return new NetworkTableValue(NetworkTableType.kStringArray, (value));
634
}
635
636
/**
637
* Creates a String[] value.
638
*
639
* @param value the value
640
* @param time the creation time to use (instead of the current time)
641
* @return The entry value
642
*/
643
public static NetworkTableValue makeStringArray(String[] value, long time) {
644
return new NetworkTableValue(NetworkTableType.kStringArray, (value), time);
645
}
646
647
@Override
648
public boolean equals(Object other) {
649
return other == this
650
|| other instanceof NetworkTableValue ntOther
651
&& m_type == ntOther.m_type
652
&& m_value.equals(ntOther.m_value);
653
}
654
655
@Override
656
public int hashCode() {
657
return Objects.hash(m_type, m_value);
658
}
659
660
// arraycopy() doesn't know how to unwrap boxed values; this is a false positive in PMD
661
// (see https://sourceforge.net/p/pmd/bugs/804/)
662
@SuppressWarnings("PMD.AvoidArrayLoops")
663
static boolean[] toNativeBooleanArray(Boolean[] arr) {
664
boolean[] out = new boolean[arr.length];
665
for (int i = 0; i < arr.length; i++) {
666
out[i] = arr[i];
667
}
668
return out;
669
}
670
671
@SuppressWarnings("PMD.AvoidArrayLoops")
672
static double[] toNativeDoubleArray(Number[] arr) {
673
double[] out = new double[arr.length];
674
for (int i = 0; i < arr.length; i++) {
675
out[i] = arr[i].doubleValue();
676
}
677
return out;
678
}
679
680
@SuppressWarnings("PMD.AvoidArrayLoops")
681
static long[] toNativeIntegerArray(Number[] arr) {
682
long[] out = new long[arr.length];
683
for (int i = 0; i < arr.length; i++) {
684
out[i] = arr[i].longValue();
685
}
686
return out;
687
}
688
689
@SuppressWarnings("PMD.AvoidArrayLoops")
690
static float[] toNativeFloatArray(Number[] arr) {
691
float[] out = new float[arr.length];
692
for (int i = 0; i < arr.length; i++) {
693
out[i] = arr[i].floatValue();
694
}
695
return out;
696
}
697
698
@SuppressWarnings("PMD.AvoidArrayLoops")
699
static Boolean[] fromNativeBooleanArray(boolean[] arr) {
700
Boolean[] out = new Boolean[arr.length];
701
for (int i = 0; i < arr.length; i++) {
702
out[i] = arr[i];
703
}
704
return out;
705
}
706
707
@SuppressWarnings("PMD.AvoidArrayLoops")
708
static Long[] fromNativeIntegerArray(long[] arr) {
709
Long[] out = new Long[arr.length];
710
for (int i = 0; i < arr.length; i++) {
711
out[i] = arr[i];
712
}
713
return out;
714
}
715
716
@SuppressWarnings("PMD.AvoidArrayLoops")
717
static Float[] fromNativeFloatArray(float[] arr) {
718
Float[] out = new Float[arr.length];
719
for (int i = 0; i < arr.length; i++) {
720
out[i] = arr[i];
721
}
722
return out;
723
}
724
725
@SuppressWarnings("PMD.AvoidArrayLoops")
726
static Double[] fromNativeDoubleArray(double[] arr) {
727
Double[] out = new Double[arr.length];
728
for (int i = 0; i < arr.length; i++) {
729
out[i] = arr[i];
730
}
731
return out;
732
}
733
734
private NetworkTableType m_type;
735
private Object m_value;
736
private long m_time;
737
private long m_serverTime;
738
}