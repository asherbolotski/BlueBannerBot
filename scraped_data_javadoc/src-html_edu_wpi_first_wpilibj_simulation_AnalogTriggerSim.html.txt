001
// Copyright (c) FIRST and other WPILib contributors.
002
// Open Source Software; you can modify and/or share it under the terms of
003
// the WPILib BSD license file in the root directory of this project.
004
005
package edu.wpi.first.wpilibj.simulation;
006
007
import edu.wpi.first.hal.simulation.AnalogTriggerDataJNI;
008
import edu.wpi.first.hal.simulation.NotifyCallback;
009
import edu.wpi.first.wpilibj.AnalogTrigger;
010
import java.util.NoSuchElementException;
011
012
/** Class to control a simulated analog trigger. */
013
public class AnalogTriggerSim {
014
private final int m_index;
015
016
/**
017
* Constructs from an AnalogTrigger object.
018
*
019
* @param analogTrigger AnalogTrigger to simulate
020
*/
021
public AnalogTriggerSim(AnalogTrigger analogTrigger) {
022
m_index = analogTrigger.getIndex();
023
}
024
025
private AnalogTriggerSim(int index) {
026
m_index = index;
027
}
028
029
/**
030
* Creates an AnalogTriggerSim for an analog input channel.
031
*
032
* @param channel analog input channel
033
* @return Simulated object
034
* @throws NoSuchElementException if no AnalogTrigger is configured for that channel
035
*/
036
public static AnalogTriggerSim createForChannel(int channel) {
037
int index = AnalogTriggerDataJNI.findForChannel(channel);
038
if (index < 0) {
039
throw new NoSuchElementException("no analog trigger found for channel " + channel);
040
}
041
return new AnalogTriggerSim(index);
042
}
043
044
/**
045
* Creates an AnalogTriggerSim for a simulated index. The index is incremented for each simulated
046
* AnalogTrigger.
047
*
048
* @param index simulator index
049
* @return Simulated object
050
*/
051
public static AnalogTriggerSim createForIndex(int index) {
052
return new AnalogTriggerSim(index);
053
}
054
055
/**
056
* Register a callback on whether the analog trigger is initialized.
057
*
058
* @param callback the callback that will be called whenever the analog trigger is initialized
059
* @param initialNotify if true, the callback will be run on the initial value
060
* @return the {@link CallbackStore} object associated with this callback.
061
*/
062
public CallbackStore registerInitializedCallback(NotifyCallback callback, boolean initialNotify) {
063
int uid = AnalogTriggerDataJNI.registerInitializedCallback(m_index, callback, initialNotify);
064
return new CallbackStore(m_index, uid, AnalogTriggerDataJNI::cancelInitializedCallback);
065
}
066
067
/**
068
* Check if this analog trigger has been initialized.
069
*
070
* @return true if initialized
071
*/
072
public boolean getInitialized() {
073
return AnalogTriggerDataJNI.getInitialized(m_index);
074
}
075
076
/**
077
* Change whether this analog trigger has been initialized.
078
*
079
* @param initialized the new value
080
*/
081
public void setInitialized(boolean initialized) {
082
AnalogTriggerDataJNI.setInitialized(m_index, initialized);
083
}
084
085
/**
086
* Register a callback on the lower bound.
087
*
088
* @param callback the callback that will be called whenever the lower bound is changed
089
* @param initialNotify if true, the callback will be run on the initial value
090
* @return the {@link CallbackStore} object associated with this callback.
091
*/
092
public CallbackStore registerTriggerLowerBoundCallback(
093
NotifyCallback callback, boolean initialNotify) {
094
int uid =
095
AnalogTriggerDataJNI.registerTriggerLowerBoundCallback(m_index, callback, initialNotify);
096
return new CallbackStore(m_index, uid, AnalogTriggerDataJNI::cancelTriggerLowerBoundCallback);
097
}
098
099
/**
100
* Get the lower bound.
101
*
102
* @return the lower bound
103
*/
104
public double getTriggerLowerBound() {
105
return AnalogTriggerDataJNI.getTriggerLowerBound(m_index);
106
}
107
108
/**
109
* Change the lower bound.
110
*
111
* @param triggerLowerBound the new lower bound
112
*/
113
public void setTriggerLowerBound(double triggerLowerBound) {
114
AnalogTriggerDataJNI.setTriggerLowerBound(m_index, triggerLowerBound);
115
}
116
117
/**
118
* Register a callback on the upper bound.
119
*
120
* @param callback the callback that will be called whenever the upper bound is changed
121
* @param initialNotify if true, the callback will be run on the initial value
122
* @return the {@link CallbackStore} object associated with this callback.
123
*/
124
public CallbackStore registerTriggerUpperBoundCallback(
125
NotifyCallback callback, boolean initialNotify) {
126
int uid =
127
AnalogTriggerDataJNI.registerTriggerUpperBoundCallback(m_index, callback, initialNotify);
128
return new CallbackStore(m_index, uid, AnalogTriggerDataJNI::cancelTriggerUpperBoundCallback);
129
}
130
131
/**
132
* Get the upper bound.
133
*
134
* @return the upper bound
135
*/
136
public double getTriggerUpperBound() {
137
return AnalogTriggerDataJNI.getTriggerUpperBound(m_index);
138
}
139
140
/**
141
* Change the upper bound.
142
*
143
* @param triggerUpperBound the new upper bound
144
*/
145
public void setTriggerUpperBound(double triggerUpperBound) {
146
AnalogTriggerDataJNI.setTriggerUpperBound(m_index, triggerUpperBound);
147
}
148
149
/** Reset all simulation data for this object. */
150
public void resetData() {
151
AnalogTriggerDataJNI.resetData(m_index);
152
}
153
}